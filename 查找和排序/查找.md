# 查找
- 查找定义：在数据集中寻找满足某种条件的元素
- 查找分类：
    - 静态查找：查找过程对查找表只查不做增删
    - 动态查找：查找过程对查找表进行动态插入或删除
- 平均查找长度：所有查找过程中比较次数的平均值。
$$
ASL = \sum_{i=1}^{n}P_{i}C_{i}
$$

Pi为查找第i个元素的概率，Ci为查找第i个元素成功/失败时所进行的比较次数。

- 判定树：是一个“类二叉排序树”，其中内部节点表示数据集中的一个元素，叶节点表示查找不成功的范围，每条边代表一次比较的判定结果。查找成功时的查找长度为从根节点到目标节点路径上的节点数，查找不成功时的查找长度为从根节点到叶节点父节点的路径上的节点数。
![](http://img.blog.csdn.net/20140822232917296)

## 顺序查找
顺序查找也叫线性查找，主要用于在线性表中进行查找。
### 无序表顺序查找
从线性表一端开始逐个检查关键字是否满足条件，如果某个元素满足条件则查找成功，如果扫描结束仍未找到则查找失败。

- 分析：
    - 时间复杂度：O(n)
    - ASL(成功) = (1+2+...+n)/n = (n+1)/2
    - ASL(失败) = n
    
### 有序表顺序查找
查找成功则返回，如果第i个小于给定关键字而第i+1个大于给定关键字或者扫描结束时仍未找到，则查找失败。

- 分析：
    - 时间复杂度：O(n)
    - ASL(成功) = (1+2+...+n)/n = (n+1)/2
    - ASL(失败) = (1+2+...+n+n)/(n+1)

## 折半查找
折半查找的思想应用广泛，不仅仅限于有序顺序表。

- 前提：关键字是位置的单调函数

- 主要思想：将待查关键字key与中间位置关键字比较，若相等则查找成功，若大于则在后半部分折半查找，若小于则在前半部分折半查找，直至查找成功或越出边界。

- 一般模板：推荐闭区间写法，简单易用

```python
# 如果查找成功则返回目标元素索引，如果查找失败则返回最后一个比它小的元素索引
def Binary_search(L,key):
    l,r = 0,len(L)-1         # 闭区间写法
    while l <= r:
        mid = l + (r-l)/2    # 防溢出，但在python中不存在溢出
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid - 1
    return r                # 如果查找失败，则L[r]<key<L[l]，l = r+1
```

- 边界处理：折半查找全程必须满足“循环不变性”，否则可能会出现死循环或边界错误。循环不变性在这里指的就是“l-r区间表示方式必须前后一致”：
    - 闭区间：用[l,r]代表当前查找的范围
    - 前闭后开：用[l,r)代表当前查找范围

```python
# 如果查找成功则返回目标元素索引，如果查找失败则返回第一个比它大的元素索引
def Binary_search(L,key):
    l,r = 0,len(L)            # 开区间
    while l < r:              # 边界写法
        mid = l + (r-l)/2
        if key == L[mid]:
            return mid        
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid           # 前半部分
    return r         # 如果查找失败,L[r]>key, l == r
```

- 变形：当列表中含有相等元素时，如果需要返回第一个或最后一个满足条件的下标，可使用last记录上一次满足条件的元素下标，把相等当做小于/大于，最后返回last。

```python
# 返回第一个满足条件的下标
def Binary_search(L,key):
    l,r = 0,len(L)-1
    last = -1
    while l <= r:
        mid = l + (r-l)/2
        if key == L[mid]:
            last = mid
            r = mid - 1
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid -1
    return last

# 返回最后一个满足条件的下标
def Binary_search(L,key):
    l,r = 0,len(L)-1
    last = -1
    while l <= r:
        mid = l + (r-l)/2
        if key == L[mid]:
            last = mid
            l = mid + 1
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid -1
    return last
```
- 分析：
    - 最坏时间复杂度：O(lgn)
    - ASL ≈ lg(n+1)-1

- 二分查找每次总是选择中间元素作为枢轴点，原则上我们可以选取[l,r]内的任一元素作为枢轴点。插值查找和斐波那契查找正是通过改变枢轴点的选取方式来改进二分查找的。

  
## 插值查找

插值查找每次通过插值的方式来选取枢轴点：

- 插值查找：`mid = l + (r-l)*(key-L[l])/(L[r]-L[l])`，其中`L[r] != L[l],L[l] <= key <= L[r]`
```python
def insertion_search(L,key):
    l,r = 0,len(L)-1
    
    while l <= r:
        if key > L[r] or key < L[l]:return -1
        if L[r] == L[l]:return r
        
        mid = int(l + (r-l)*(key-L[l])/float((L[r]-L[l])))
        if key == L[mid]:  
            return mid
        elif key > L[mid]: 
            l = mid + 1
        else:              
            r = mid - 1
    return -1
```

- 分析：平均时间复杂度O(loglogN)，当关键字在数据集中分布较均匀时性能最好，当分布不均时可能比折半要差

## 斐波那契查找
```python
F = [0,1]
def Fibonacci(k):
    if k < len(F):
        return F[k]
    else:
        p = Fibonacci(k-1) + Fibonacci(k-2)
        F.append(p)
    return p


def Fibonacci_Search(L,key):
    n = len(L)
    k = 0
    while n > Fibonacci(k) - 1:
        k += 1
    L = L + L[-1:] * (F[k]-1-n)
    print(k,L)
    l,r = 0,n-1
    while l <= r:
        mid = l+ F[k-2]
        if key == L[mid]:
            if mid >=n:
                return n-1
            else:
                return mid
        elif key > L[mid]:
            l = mid + 1
            k -= 1
        else:
            r = mid - 1
            k -= 2
    
    return -1
```














