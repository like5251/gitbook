# 动态规划（DP）

## 使用环境

> 动态规划\(dynamic programming\)用于求解多阶段决策过程\(decision process\)的最优化问题。

### 多阶段决策过程的最优化问题

* 多阶段决策过程：如果某个过程可以划分为多个相互联系的阶段，在每个阶段都必须做出决策，每次决策都会使过程的状态发生转移，则称该过程为多阶段决策过程。多阶段决策过程可以用状态迁移图来表示，它是一个有向无环图（DAG图）。

![](http://p10.qhimg.com/t0127c4c71e82c422c4.jpg)

* 阶段：决策过程的某个步骤，对应DAG图的拓扑排序中的一轮
* 状态：决策过程所处的客观情况，对应DAG图中的节点
  * 状态变量：用于描述状态的一组数，节点编号
* 决策：在某个状态下所作出的选择，状态在决策作用下转移至它的一个后继状态，对应于DAG图中的边
  * 决策变量：用于描述决策使一组数，边权值
  * 初始状态：决策前的状态，边的起始节点
  * 结束状态：决策后的状态，边的结束节点
  * 前趋状态：当前状态的前一个状态，一个状态可能有多个前趋状态，前驱节点
  * 后继状态：当前状态的下一个状态，一个状态可能有多个后继状态，后继节点
* 目标函数：过程处于某个状态时，对应子问题的最优解关于状态变量的函数，节点权值
* 状态转移方程：在状态转移过程中，转移前后状态的目标函数之间的转移规律，节点权值与其所有前趋或后继节点权值的关系
* 策略：各阶段决策所组成的决策序列，对应始末节点之间的一条路径
* 最优策略：使过程达到最优的策略称最优策略，对应于最优路径
* 多阶段决策过程的最优化问题：在多阶段决策过程中寻找某个问题（由题目给出）的最优解

我们可以通过三种视角来理解多阶段决策过程最优化问题：

| 决策过程 | DAG图 | 求解过程 |
| --- | --- | --- |
| 阶段 | 拓扑排序的一个阶段 | 子问题解的依赖层级 |
| 状态 | 节点 | 子问题 |
| 状态变量 | 节点编号 | 子问题参数 |
| 决策 | 有向边 | 子问题之间的演化关系 |
| 决策变量 | 边的权值 | 子问题演化路径选择 |
| 初始状态 | 边起始顶点 | 初始子问题 |
| 结束状态 | 边的结束顶点 | 目标子问题 |
| 前趋状态 | 前趋节点 | 生成子问题的上一个子问题 |
| 后继状态 | 后继节点 | 子问题所生成的下一个子问题 |
| 目标函数 | 节点权值 | 子问题最优解的值 |
| 状态转移方程 | 结点权值关系 | 子问题最优解关系 |
| 策略 | 始末节点的一条路径 | 问题可行解 |
| 最优策略 | 始末节点间的最优路径 | 问题最优解 |

### 问题特征

能够通过动态规划求解的问题必须满足以下三个特征：  
1. 最优子结构：问题的最优解包含了子问题的最优解，通过组合子问题的最优解能够得到原问题的最优解。也就是说，如果原问题达到最优则子问题一定达到最优，但反之如果子问题达到最优原问题不一定达到最优。  
2. 无后效性（子问题独立性）：当前状态一旦确定，后续过程演化不再受此前状态和决策的影响。简单的说就是当前的状态是此前历史的一个完整总结，此前的历史只能通过当前的状态去影响过程未来的演变，“未来与过去无关”。  
3. 重叠子问题：不同子问题包含有公共子子问题。摆脱重叠子问题的重复求解是动态规划算法的根本动机。动态规划算法对每个子问题只求解一次，并进行存储，动态规划实质上是一种以空间换时间的技术。重叠子问题越多，动态规划的性能优越性就越明显。

## 解决方案

动态规划算法就是在多阶段决策过程中寻找问题最优解的方法：过程的每个状态都**标记**了一个与状态相关的子问题，而状态的目标函数则代表了该子问题的最优解，状态通过决策转移，状态转移方程则描述了转移前后状态的目标函数之间的关系，如果我们首先得到边界状态的目标函数值，在状态转移方程的作用下就可以动态地得到所有状态的目标函数值，也就是所有子问题的最优解。因为子问题的最优解是在状态转移过程中动态求解的，因此这种方法被称为动态规划。

> 动态规划的求解过程类似于数学归纳法、递归、深度优先遍历、拓扑排序过程

通过动态规划算法求解多阶段决策过程最优化问题的一般步骤：

> 1. 构造最优子结构——通过子问题最优解刻画原问题最优解
> 2. 递归定义问题最优解——状态转移方程
> 3. 算法实现——填表法

### 构造最优子结构

构造最优子结构就是思考如何通过子问题的最优解构造出原问题的最优解。

* 两种常见的构造思路：

* 顺推：子问题最优解被定义为从初始状态到当前状态的最优解。对给定状态S，需要找到S所有的前趋状态，然后找到由这些前趋状态最优解构造出状态S最优解的方法；

* 逆推：子问题最优解被定义为从当前状态到结束状态的最优解。对给定状态S，需要找到S所有的后继状态，然后找到由这些后继状态最优解构造出状态S最优解的方法；如[Triangle](https://leetcode.com/problems/triangle/tabs/description)。

* 构造最优子结构的一般步骤：
* 定义子问题/状态：子问题应满足两个条件，一是可以通过这些子问题的最优解构造出原问题的最优解；二是与其前趋或后继状态有决策关联；
* 寻找前趋/后继状态：根据当前阶段的决策可找到当前状态的所有后继状态，同理根据上阶段的决策可以找到当前状态的所有前趋状态；
* 由前趋/后继状态最优解构造当前状态最优解：根据子问题及决策的性质可以找到前趋/状态与当前状态最优解的关系。

最优子结构是打开动态规划大门的钥匙，之后剩下的都只不过是套路。

### 定义状态转移方程

递归定义状态转移方程，需特别注意递归的边界条件。正确写出状态转移方程，在编写代码时就可直接套用固定的形式。

### 算法实现

动态规划算法可形象地理解为一种“填表法”，表格的不同维度代表了状态变量的不同分量，表格中的值代表了不同状态变量下的状态函数值，表格中不同的位置的值依据状态转移方程相互关联。

问题的求解过程即是表格的填写过程：初始状态下我们先将初始边界值填入到表格，然后根据状态转移方程一步步地将剩余子问题的解填入到表格（每填写一个新的位置，必须保证它所依赖的其它位置均已被填写），当表格填满时也就得到了原问题的解。

填表法一般过程：

1. 创建表格：一般以多维数组或列表表示，在创建表格时进行合适的初始化非常重要
2. 填写表格：按规模从小到大依次求解并填入表格
3. 返回最优解：返回表格中原始规模问题的解

![](http://hi.csdn.net/attachment/201112/13/0_13237484453fFF.gif)

有两种方式来完成“填表过程”：  
1. 自顶向下记忆化递归法：当需要计算子问题时，检查该子问题的解是否已保存，如果是则直接返回所保存的解，反之则按常规方法计算该子问题的最优解并保存；

```
# 自顶向下记忆化递归法的一般过程
1）创建表格
    表格维度：状态变量的维度
    表格各维范围：状态变量对应维度取值范围
    表格初始化：表格初始化为不可能为子问题解的值，以便于标记子问题是否已求解，如正负无穷
2）递归填写表格
    定义递归函数：返回并写入子问题的最优解
    检测子问题是否已求解（检测是否为初始值）
        如果已求解，则直接返回表格中的值
        如果未求解，则按常规方法求解
            创建一个临时变量来缓存子问题的中间解
            求解边界状态
            递归求解一般状态：状态转移方程，如果有众多决策，需要循环决策
            将子问题的解写入表格
3）返回原问题的最优解
    调用递归函数，初始状态作为参数
```

1. 自底向上递推法：按规模大小依次求解并保存子问题的解，保证在求解每个子问题时其所依赖的更小的子问题均已求解并保存；

```
# 自底向上递推法的一般过程

   1）创建表格
    同上，只是初始化方法不同。
    递推法不需要检测问题是否已求解，初始化时也就无需再设置荒谬解。
    通过合理设置表格初始值，可以大大简化边界状态的处理，有三种常见的方式：
    ① 做任意初始化，但后续要分别讨论边界状态和一般状态
    ② 将边界状态的最优解作为初始值，后面只需处理一般状态即可；
    ③ 将递推公式推广到边界状态，扩展表格，并将边界状态所依赖的虚拟状态最优解作为表格初始值；
    则后续可将边界状态作为一般状态来处理。

2）递推填写表格  
    递推过程一般包括两层循环：  
    外层循环：按问题规模循环状态，求解所有状态，并写入表格  
        求解边界状态（合理的初始化可避免这一步）  
        递推求解一般状态  
            内层循环：循环决策

3）返回原问题最优解  
    返回初始状态在表格中的值
```

对比：递归灵活且书写简单，递推高效且方便优化（如通过滚动数组减少空间消耗、合理组织状态降低时间复杂度等）

## 算法分析
### 时间复杂度
子问题图/状态转移图描述了子问题/状态之间的依赖关系，每个顶点唯一对应一个子问题，每条有向边对应于两个子问题之间的依赖关系。

![](http://img.blog.csdn.net/20150506092445168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3F0Y2dx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

算法的运行时间等于每个子问题求解时间之和，每个子问题的求解时间和对应顶点的出度（决策数）和转移费用成正比。因此：

    时间复杂度=状态数×决策数×转移费用

### 空间复杂度
动态规划算法是一种以空间换取时间的技术，它基于“填表法”，空间复杂度等于表格容量，即状态变量各分量的乘积，可通过降低状态变量维度的方法减小空间复杂度。

    空间复杂度 = 状态维数的乘积
## 实例分析
### Triangle

- 问题描述：给定一个三角形，寻找从顶部到底部最短路径，每一步可以移动至下一行的相邻数字。

```
[  
     [2],  
    [3,4],  
   [6,5,7],  
  [4,1,8,3]  
]  
最优解为11（2 + 3 + 5 + 1 = 11）
```

- 问题分析：每一步都需要在下一行的相邻元素中作出选择，每组选择构成一个可能的解，需要在所有可行解中寻找出最优解。这是一个多阶段决策最优化问题，下面来验证它是否满足使用动态规划的三个特征：
    - 最优子结构，在自顶向下的最短路径中取任一点，它到底部的子路径也必然是最短路径；
    - 无后效性，三角形中某点到底部的最短路径与该点如何得来的无关；
    - 重叠子问题，以3开始的子路径和以4开始的子路径包含了公共子子路径以5开始的子路径；

该问题可使用动态规划方法高效地进行求解，状态转移图如下：

![](http://note.youdao.com/yws/api/personal/file/WEB995f468f39bcad9d89de224e40bd462a?method=download&shareKey=452e25c8c0f6e387a8cc1bb23eefc58e)
- 问题求解：
    1. 寻找最优子结构：按照逆推的方式，要求li[i][j]元素到底部的最短路径，需要先找到该子问题的所有后继状态，很明显该子问题的后继状态只有两个，分别是li[i+1][j]和li[i+1][j+1]到底部的最短路，然后可通过这两个后继状态最优解构造出该子问题的最优解：后继状态最优解中的最小值加上li[i][j]就得到当前子问题的最优解。根据我们对子问题的描述方式可以自然地得到状态的定义:(i,j)表示求解li[i][j]到底部的最短路径的子问题；状态函数的定义d(i,j)表示li[i][j]到底部的最短路径。
    2. 定义状态转移方程：在寻找最优子结构时，事实上已经找到了状态转移方程，不过现在需要通过递归定义将其完整定义出来：

$$
d[i][j] = \begin{cases}
min(d[i+1][j],d[i+1][j+1])+li[i][j] &\text{if } 0\leq i < len(li)  \\
li[i][j] &\text{if } i = len(li)
\end{cases}
$$
1. 算法实现——填表法：以下两个算法可作为动态规划的一般模板使用，形式是一样的，变化只在内容上。

![](http://note.youdao.com/yws/api/personal/file/WEB11a1416ec347c624e43a14c220480309?method=download&shareKey=56b5c2c4b773717dd4fee726855b630a)

```python
# 一、 自底向上递推法
def minimumTotal(self, triangle):
    """
    :type triangle: List[List[int]]
    :rtype: int
    """
    r = len(triangle)
    # 1、创建表格：用于存储所有子问题最优解，一般初始化为不可能为解的值便于标识未求解的子问题，
    #   如果边界状态的最优解一致，一般将表格初始化为边界状态
    res = [[0] * r for i in xrange(r)]
    # 2、填写表格：按照规模大小自底向上依次填写
    for i in xrange(r-1,-1,-1):
        for j in xrange(i+1):   # 外层循环：状态循环
            if i == r - 1:          # 求解边界状态
                res[i][j] = triangle[i][j]
            else:                   # 求解一般状态 
                                        # 内层循环：决策循环，每个决策可能需要额外转移费用
                res[i][j] = min(res[i+1][j],res[i+1][j+1]) + triangle[i][j]
    # 3、返回最优解：返回表格中规模最大的解
    return res[0][0]

# 二、自顶向下记忆化递归法
def minimumTotal(self, triangle):
"""
:type triangle: List[List[int]]
:rtype: int
"""
r = len(triangle)
# 1、创建表格：用于存储各个子问题的最优解，因为需要检测是否已求解，故初始化为不可能为解的值，用于标识问题是否求解
res = [[0] * r for i in xrange(r)]

# 2、填写表格：自顶向下递归填写
def mini(i,j):
    if res[i][j] > 0:   # 检测子问题是否已求解
        return res[i][j]    # 如果已求解，则直接读取返回
                            # 如果未求解，则按照常规方法求解并保存
    q = 0                       # 设置临时变量存储用于暂存子问题的解，初始化为不可能的值   
    if i == r - 1:              # 求解边界状态
        q = triangle[i][j]
    else:                       # 递归求解一般状态
                                    # 涉及多个决策时，可能需要循环决策
                                    # 每个决策可能需要额外开销
        q =  min(mini(i+1,j),mini(i+1,j+1)) + triangle[i][j]
    res[i][j] = q               # 存储子问题的解
    return q                    # 返回子问题的解

# 3、返回原问题的最优解
return mini(0,0)
   ```

   * 算法分析

2. 时间复杂度分析：状态数=`$n^{2}$`,决策数=2，故时间复杂度=状态数×决策数=`$O(n^{2})$`
3. 空间复杂度分析：空间复杂度=状态数=`$O(n^{2})$`

### Longest Valid Parentheses

* 问题描述：给定一个由'\('和'\)'组成的字符串，找到最长合法括号子串。如"\)\(\)\(\)\)"，返回4 。
* 问题分析

  * d\[i\]：以i开头的最长合法括号子串
  * 若s\[i\] = '\)'，则d\[i\] = 0
  * 若s\[i\] = '\('，则"\("" + "d\[i+1\]" + "\("或"\)" +...
  * 另j = i+1+d\[i+1\]，若s\[j\] = "\("，则d\[i\]=0，若s\[j\]="\)"，则d\[i\] = d\[i+1\] + 2 +d\[j+1\] 

$$
d[i]= \begin{cases}
0&\text{if } s[i]='(' \text{ or } i=n-1 \\
j = d[i+1] + i +1&\text{if } s[i]=')'  \text{ and } i < n-1\text{ then:}\\
0&\text{if } s[j]='(' \text{ or }j=n-1 \\
d[i+1]+2+d[j+1] &\text{if } s[j]=')'  \text{ or }j<n-1
\end{cases}
$$

* 算法实现
  ```python
  def longestValidParentheses(s):
    """
    :type s: str
    :rtype: int
    """
    n = len(s)
    # 1、创建表格
    d = [0] * (n+1)
    # 2、填写表格
    for i in xrange(n-1,-1,-1):
        # 通过合理设置表格初始值，极大简化了边界状态的讨论
        # 无需单独讨论s[i] = ')'或i = n-1 或j = n或s[j] = '('或j+1=n
        if s[i] == '(':             
            j = d[i+1] + i + 1        
            if j < n and s[j] == ')':
                d[i] = d[i+1] + 2 + d[j+1]    
    # 返回最优解            
    return max(d)
  ```
* 算法分析

  状态数为n，决策数为2

  * 时间复杂度：`$O(n)$`
  * 空间复杂度：`$O(n)$`

## 常用DP模型

### 线性DP

线性模型最容易导致动态规划算法，常用的方法有：  
1. 把线性结构分成两部分，尝试递归解决；  
2. 每次增加一个元素，逐步扩大考虑范围；

* 顺推
* 逆推

* 钢条切割
* LIS
* LCS
* 合唱队队形

### 区间DP

这一类题目的关键是用区间来表示状态，并建立合理的状态转移方程:

* 括号问题
* 二叉搜索树个数
* 最长回文子序列

### 树状DP

树本身就是一种递归结构，很多情况下都可以用动态规划来求解

### 背包问题

### 最短路径问题

### 股票买卖问题

## 算法比较

### DP与分治

### DP与递归

### DP与贪婪



