## 分治递归

### 递归（Recursion）
递归定义：在一个函数或数据结构的定义中又应用了它自身
递归算法：算法直接或间接调用自身

递归的两个要素：
1. 递归表达式：规模较小子问题的解和规模较大子问题的解的递推关系。在问题分解阶段，根据递归表达式将规模较大子问题分解为规模较小的子问题，在合并节点，根据递归表达式将规模较小子问题的解合并为规模较大子问题的解。
2. 边界条件：递归的出口，是分解/调用的终点和合并/返回的起点

以斐波那契数列为例，其定义为：

$$
fib(n)\begin{cases}
0 & \text{ if } n= 0\\ 
 1& \text{ if } n= 1\\ 
 fib(n-1)+fib(n-2)& \text{ if } n\geqslant 2 
\end{cases}
$$

算法实现：

```python
def fib(n):
    if n == 0:return 0
    if n == 1:return 1
    return fib(n-1) + fib(n-2)
```

递归的执行过程是对递归树进行深度优先遍历的过程：

![](/assets/递归执行过程.gif)

### 分治（Divide And Conquer）
分治思想：将原问题分解为多个规模较小的同类子问题，然后递归求解这些子问题，最后再通过合并子问题的解得到原问题的解。

在每层递归中应用如下三个步骤：
1. 分解：将问题划分为一些子问题；
2. 求解：递归求解同类子问题，对于非同类的子问题，将其看做是合并的一部分；
3. 合并：将子问题的解合并为原问题的解；

说明：严格说来，分治和递归是两种不同的算法设计思想。分治是将问题横向分解为多个同层级的子问题，对这些子问题进行“分而治之”，最后再将子问题的解合并得到原始问题的解。递归则是将问题纵向分解为多个层级的子问题，当最底层问题解决之后，可以层层返回得到原始问题的解。但要完整解决一个实际问题，往往需要同时对它进行横向和纵向的分解，因此分治和递归几乎总是一起使用的。

以求解斐波那契数fib(4)为例，将fib(4)分解为fib(3)、fib(2)和fib(3)+fib(2)三个子问题，分别求解fib(3)和fib(2)，再将子问题的解合并fib(3)+fib(2)的过程基于分治思想。将fib(4)层层向下分解，再由最底层的解层层向上返回的过程基于递归思想。分治和递归一起构成了整个求解过程。

![](/assets/分治-递归.jpg)

### 分治递归算法分析
#### 时间复杂度
计算分治算法时间复杂度的核心是求解算法运行时间的递归式。递归式是一个等式或不等式，它通过更小输入上的函数值来描述一个函数。以斐波那契数列为例，运行时间的递归式如下：

$$
T(n) = T(n-1) + T(n-2)
$$

求解递归式的一般方法：
1. 数学归纳法：先猜测解的形式，然后用数学归纳法求出解中的常数
2. 递归树法：每个节点代表某次递归调用产生的代价，然后将所有层级的代价求和
3. 主定理：只能用于求解特定形式的递归式

$$
T(n) = aT(n/b) + f(n)
$$

说明：
- 忽略细节：在求解递归式时，常常忽略向下取整、向上取整及边界条件，这些细节一般不会影响其渐进界
- 不等式：如果递归式描述的是T(n)的一个上界，可用大O记法描述其解；如果描述的是一个下界，则用Ω记法描述其解。

递归算法代码简单易于理解，但是由于函数调用的开销、对于同一个子问题可能会进行多次求解导致递归效率低下。

#### 空间复杂度
在递归过程中，系统开辟了一个递归工作栈进行数据存储，递归算法的空间复杂度是O(h)，h代表最大递归深度，如果递归次数过多可能造成栈溢出。


















