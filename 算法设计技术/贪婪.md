# 贪心算法

## 算法综述
- 问题分析：和动态规划类似，贪心算法同样用于求解多阶段决策最优化问题，问题具有最优子结构，和动态规划不同的是，贪心算法适用的问题不具有重叠子问题，而具有贪心选择性质。
- 算法设计：贪心算法在每个阶段做出当时看来最优的选择（贪心选择），将问题转化为贪心选择+剩余子问题，然后可将子问题进一步划分为下阶段的贪心选择+子子问题，整个贪心选择序列产生出原问题的最优解。
- 算法实现：贪心算法一般使用递归或迭代以自顶向下的方式来实现，每次递归或迭代都得到当前的最优选择
- 算法分析：除去使用贪心算法之前的准备工作，贪心算法与贪心选择数成正比

贪心VS动态规划

--|动态规划|贪心
---|---|---
问题|最优子结构、重叠子问题|最优子结构、贪心选择
设计|由子问题最优解通过状态转移方程得到问题最优解|贪心选择+子问题
实现|自底向上迭代、自顶向下记忆式递归|自顶向下递归、迭代

贪心算法并不能保证总能得到问题最优解，真正要做的全部工作就是论证将贪心选择和子问题最优解组合在一起就能生成原问题的最优解。使用贪心算法能够解决的问题使用动态规划也能解决，但是有些杀鸡用牛刀了，如果能证明问题具有贪心选择的性质，贪心算法将会是一种更简单、更高效的算法。

## 问题分析
使用贪心算法前需验证问题满足以下两个特征：

- 最优子结构：当问题达到最优解时，它所包含的子问题也达到最优解。
- 贪心选择性质：贪心选择和剩余子问题可同时达到最优。在问题求解的每个阶段都面临着诸多选择，每种选择都会产生对应的剩余子问题，如果能证明当做出贪婪选择时，对应的剩余子问题相比其他选择所生成的剩余子问题也是最优的，那么贪心选择和剩余子问题的最优解就可以组合出原问题的最优解。

寻找“贪心选择”是使用贪心算法的关键，原始问题通常不易直接观察，往往需要先通过排序或其他手段来寻找贪心选择！
## 算法设计
可以通过递归或迭代来实现自顶向下的贪心算法：
- 递归：问题最优解 = 贪心选择 + 剩余子问题的最优解
- 迭代：通过每阶段的贪心选择更新问题最优解

## 算法实现
### 递归

### 迭代

## 算法分析

## 算法实例
### 1. 箭射气球
[原题LeetCode452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

- 问题：给出每个气球在x轴的起始坐标，如果从x轴垂直射箭，至少需要多少支箭才能把所有气球打下？
    - 输入：[[10,16], [2,8], [1,6], [7,12]]
    - 输出：2

- 思路：先按每个气球的终止坐标排序，以第一个气球结束位置🏹，排除能够射中的气球，再以第一个未被射中的气球的终止坐标作为新的发射点，遍历过程中计数箭射出的次数
- 算法：排序-遍历

```
def findMinArrowShots(self, points):
    """
    :type points: List[List[int]]
    :rtype: int
    """
    points.sort(key=lambda (x,y):(y,x))
    n = len(points)
    if not n:return 0
    res = 1
    cur = points[0][1]
    
    for p in points:
        if p[0] >cur:
            res += 1
            cur = p[1]
    return res
```
### 2. 不重叠间隔
[435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/description/)
- 问题：给出一组间隔，至少去掉多少个可以使它们相互不重叠
    - 输入：[ [1,2], [2,3], [3,4], [1,3] ]
    - 输出：1

- 思路：先按每个间隔的终止坐标排序，从前向后遍历，如果当前开始数值小于前一个的结束坐标，则把当前间隔删除
- 算法：排序-遍历
```
def eraseOverlapIntervals(self, intervals):
    """
    :type intervals: List[Interval]
    :rtype: int
    """
    # 方法一：先按结尾数字排序，如果后面start<前面end就要将后面的删了
            
    end = float('-inf')
    erased = 0
    for i in sorted(intervals, key=lambda i: i.end):
        if i.start >= end:
            end = i.end
        else:
            erased += 1
    return erased
```
### 3. 加油站
[134.Gas Station](https://leetcode.com/problems/gas-station/description/)
- 问题：n个加油站构成一个环，第i个加油站储油gas[i]，从i加油站到i+1加油站耗油cost[i]。一辆空油坦克从某个加油站出发是否能够行走一圈，如果能返回该加油站的小标，如果不能返回-1
    - 输入：gas[] cost[]
    - 输出：index或-1

- 思路：
    -  如果gas总和大于等于cost总和，则必存在一个加油站，从它出发就能遍历整个环，反之不存在
    -  从0出发当遇到第一个gas总量<cost总量的站点时，说明0~该站之间的任何站都不能作为出发点，因为在这中间任一点之前，gas总量都是大于cost总量的，现在总体却小于cost总量，从中间任一点出发这一段都只能是负的！
- 算法：排序-遍历
```
def canCompleteCircuit(self, gas, cost):
    """
    :type gas: List[int]
    :type cost: List[int]
    :rtype: int
    """
    res = 0
    cur = total = 0
    start = 0
    for i in xrange(len(gas)):
        total += gas[i] - cost[i]
        cur += gas[i] - cost[i]
        if cur < 0:
            start = i + 1
            cur = 0
    return -1 if total < 0 else start
```
[]