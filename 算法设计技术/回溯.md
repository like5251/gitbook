## 算法综述
回溯法（Backtracking）是暴力搜索法的一种，用于求解约束满足问题。回溯法以深度优先搜索的方式在问题的解空间树（状态空间树/决策树）中搜索所有可能的解，当发现原先的选择达不到目标，就退回一步重新尝试新的选择，当得到了问题的一个解时，如果需要搜索剩余的解，同样退回一步尝试新的选择，这种走不通就退回去换条路再走的技术叫回溯法。

## 适用问题
回溯法多用于求解“多阶段决策过程中满足约束条件的所有解”问题。

和DP类似，我们可以用一棵决策树来描述所要解决的问题（DAG-决策-问题）：
1. 每个节点代表了当前过程所处的状态（标记了一个子问题）
2. 节点的每条有向边代表了当前状态下可用的选择（问题的演化）
3. 根节点代表了过程初始状态（原始问题）
4. 叶节点代表了问题的终止状态（边界问题）
5. 从根节点到叶节点的一条路径代表了原始问题的一个解

![](/assets/回溯.jpg)

- 活节点：能向纵深扩展的节点
- 死节点：不能纵深扩展的节点，已被证明通过它无法得到解或通过它的所有解均已获取过的节点

## 解决方案
以DFS的方式在问题的解空间树中搜索所有可能的解：
1. 如果发现该节点不合法，则返回到上一层（减枝）
2. 如果发现该节点为叶节点，说明得到了问题的一个解，保存解之后返回上一层（存解）
3. 否则递归调用它的所有邻接点（扩展节点）

说明：减枝操作（步骤1）也可以与第三步合并，只递归调用合法的邻接点，这样可以有效减少递归深度。
1. 如果发现该节点为叶节点，说明得到了问题的一个解，保存解之后返回上一层（存解）
2. 否则递归调用它的所有合法邻接点（扩展节点、减枝）

## 算法实现
回溯过程用到三种参数：
1. 状态参数：描述当前节点的状态
2. 中间解：从根节点到当前节点的搜索路径中得到的部分解
3. 最终解：存储已搜索到的从根节点到叶节点的全局解

一般范式：

```python
# 范式一：进入节点后检查
res = []                        # 存储全局解
def dfs(node,cur,res):
    """
    node:状态参数
    cur:中间解
    res:全局解
    """
    if cut(node):                # 如果满足减枝条件，直接返回
        return
    if condition(node):          # 如果到达叶节点，保存结果后返回
        res.append(cur)
        return
    for x in node.adjs:          # 递归调用所有邻接点
        dfs(x,f(cur),res)

# 范式二：进入节点前检查
res = []                        # 存储全局解
def dfs(node,cur,res):
    if condition(node):         # 如果到达叶节点，保存结果后返回
        res.append(cur)
        return
    for x in node.adjs:
        if not cut(x):          # 递归调用合法邻接点
            dfs(x,f(cur),res)
```
## 算法分析





312
