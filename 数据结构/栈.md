# 栈
## 数据结构
### 栈中术语
- 栈：只允许在一端进行插入或删除的线性表
- 栈顶：允许插入和删除的那一端
- 栈底：不允许插入和删除的那一端
### python实现
python中直接使用列表就可以作为栈的数据结构：

```python
# 栈
stack = []
# 栈顶
stack[-1]
# 栈底
stack[0]
```
## 栈的基本操作
### 基本操作
- 创建空栈
- 入栈
- 出栈
- 读取栈顶
- 判断栈是否为空

### python实现
```python
# 创建空栈
stack = []
# 入栈
stack.append(obj)
# 出栈
p = stack.pop()
# 获取栈顶/栈底对象
stack[-1]
stack[0]
# 判断栈是否为空
if stack
```
## 栈的应用
### 卡特兰数
> Cn表示长度2n的dyck word的个数。Dyck word是一个有n个X和n个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。以下为长度为6的dyck words:
> 
> XXXYYY XYXXYY XYXYXY XXYYXY XXYXYY

- 卡特兰数的通项公式可表示如下,方便记忆

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9434815d6487cd3786fd39f533175c6ad99c7c6)
- 递推式：方便递归计算

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/2457ef163463e291b935bfb0b732f72ab99eec5a)

- 证明：镜像法

    - 令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含n个1、n个0的2n位二进制数共有 `$\binom{2n}{n}$`个，下面考虑不满足要求的数目

    - 考虑一个含n个1、n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况），则后面的0-1排列中必有n-m个1和n-m-1个0。将2m+2及其以后的部分0变成1、1变成0，则对应一个n+1个0和n-1个1的二进制数$$\binom{2n}{n+1}$$
    
#### n个元素的出栈序列数
> n个不同对象依次进出栈，能够得到`$C_{n}$`种不同出栈序列

分析：如果将入栈作为1，出栈作为0，则每个进出栈过程可表示为01序列，要求序列任何前缀中进栈次数大于等于出栈次数。

    10110010111000

#### n对括号组成的合法序列数
> n对'()'组成的合法括号序列个数

分析：合法括号等价于括号序列的所有前缀中左括号个数大于等于右括号个数。

    ((())) ()(()) ()()() (())() (()())

#### n个内部节点组成的满二叉树个数
分析：满二叉树中内部节点个数比叶节点数小1，对于有n个内部节点的满二叉树来说，必然有n+1个叶子节点。在树的先序遍历序列中，最后一个节点一定是叶子节点，如果将此叶子去掉，前面2*n个节点组成的先序遍历序列是dyck word。

![](https://upload.wikimedia.org/wikipedia/commons/0/01/Catalan_number_binary_tree_example.png)

#### n个节点组成的二叉树个数
分析：等价于n个内部节点组成的满二叉树个数，加满叶子就变成了上一个问题。原形表示节点，月牙表示什么都没有。

#### n×n网格不越过对角线的路径数
> Cn表示所有在n × n格点中不越过对角线的单调路径的个数。一个单调路径从格点左下角出发，在格点右上角结束，每一步均为向上或向右。

分析：计算这种路径的个数等价于计算Dyck word的个数：X代表“向右”，Y代表“向上”。下图为n = 4的情况

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Catalan_number_4x4_grid_example.svg/690px-Catalan_number_4x4_grid_example.svg.png)

#### 实例
##### 问题一：验证先序遍历序列/括号序列是否合法
- 问题1：[Verify Preorder Serialization of a Binary Tree](https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/)。验证给定一个先序遍历是否是否合法。
- 分析：借助栈结构，扫描先序序列（排除最后一个节点），内部节点则入栈，外部节点则出栈，如果出栈时栈已空则说明序列不合法。
- 代码以下：

```
def isValidSerialization(self, preorder):
    """
    :type preorder: str "9,3,4,#,#,1,#,#,2,#,6,#,#"
    :rtype: bool
    """
    li = preorder.split(',')
    n = len(li)
    m = li.count('#')
    if n != 2*m - 1 or li[-1] != '#':
        return False
    
    stack = []
    for c in li[:-1]:
        if c.isdigit():
            stack.append(c)
        else:
            if stack:
                stack.pop()
            else:
                return False
    return True
```

##### 问题二：找到所有合法序列
- 问题：输出n对括号所有合法序列，如：n = 3时

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```
- 分析：使用递归解决，genetate(p,left,right)返回在当前括号序列为p，仍有left个左括号right个右括号可以使用时所有合法括号
- 代码以下
```
def generateParenthesis(self, n):
    """
    :type n: int
    :rtype: List[str]
    """
    def generate(p, left, right):
        if right >= left >= 0:
            if not right:yield p
            for q in generate(p + '(', left-1, right): yield q
            for q in generate(p + ')', left, right-1): yield q
    return list(generate('', n, n))    
```
### 计算表达式
#### 表达式和表达式树
1. 表达式
- 中缀表达式：运算符位于操作数中间，运算符按照优先级依次运算。A+B×(C-D)-E/F
- 前缀表达式：运算符位于操作数前面，运算符符自右向左依次运算。-+A×B-CD/EF
- 后缀表达式：运算符位与操作数后面，运算符自左向右依次运算。ABCD-×+EF/-

表达式是递归定义的，前一个运算符的运算结果会作为下一个运算符的操作数，下一个运算符的运算结果又会作为下下一个运算符的操作数，最终返回整个运算的结果。前缀表达式又称为波兰式，后缀表达式称为逆波兰式(Reverse Polish notation，RPN)。

2. 表达式树

表达式可以表示为一颗表达式树：运算符作为内部节点，操作数作为叶节点，子表达式作为内部节点的左右子树。
- 中缀表达式：对应表达式树的中序遍历
- 前缀表达式：对应表达式树的先序遍历
- 后缀表达式：对应表达式树的后序遍历

![](http://img.blog.csdn.net/20140304145300156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlucmFpc2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

3.  表达式转换

转换方法：虽然中缀表达式、前缀表达式、后缀表达式表现方式不一样，但是运算符的运算顺序却是是统一的。因此按照表达式的统一的运算顺序，依次将旧表达式的字表达式转化为新表达式的子表达式，最终得到整个新表达式。

#### 表达式转换算法

##### 中缀转后缀

思路：优先级高的先出栈、先执行
    
    1. 初始化两个栈：操作符栈S1、中间结果栈S2
    2. 自左向右遍历中缀表达式
    3. 遇到操作数A时，将其压入S2
    4. 遇到操作符‘#’时，比较它与S1栈顶操作符的优先级：
        4.1. 如果栈非空且‘#’优先级小于等于栈顶优先级，则S1循环出栈并压入栈S2，直至栈为空或者#优先级高于栈顶优先级，将#入栈
        4.2. 如果栈为空或#优先级高于栈顶优先级，则直接将#入栈
    5. 遇到括号时
        5.1. 如果是左括号直接入栈S1
        5.2. 如果是右括号，栈s1循环出栈并压入S2，直至遇到左括号直接出栈相消
    6. 遍历结束时，将栈S1中的运算符循环出栈并压入S2
    7. 最后栈S2依次出栈，它的逆序即为最终的后缀表达式
技巧：

    为了统一处理括号和一般操作符，可适当设置不同操作符在栈中和栈外的优先级：
    1. 当栈非空且栈外运算符优先级小于栈顶优先级，则循环出栈
    并压入栈S2，直至栈空或栈外运算符优先级大于等于栈内优先
    2. 当栈外运算符优先级等于栈顶优先级，说明是栈外是右括号，栈顶是左括号，直接出栈相消
    3. 当栈空或栈外运算符优先级高于栈顶优先级，则直接入栈
    
    
操作符|(|*,/|+,-|)
---|---|---|---|---
栈内优先级|1|5|3|6
栈外优先级|6|4|2|1

说明：同种操作符，栈内的优先级高是因为中缀表达式中前面的运算符会先执行；左括号优先级总是大于前面运算符小于后面运算符，右括号优先级总是大于前面括号内的运算符。
python算法
```
mid = 'A+B*(C-D)-E/F'
def mid_pos(str):
    # 定义栈内栈外各操作符优先级
    dic_in = {'(':1,'*':5,'/':5,'+':3,'-':3,')':6}
    dic_out = {'(':6,'*':4,'/':4,'+':2,'-':2,')':1}
    # 定义操作符栈和中间结果栈
    ope = []
    res = []
    # 遍历中缀表达式
    for c in mid:
        # 如果是操作数，压入res
        if c.isalpha():
            res.append(c)
        # 如果是操作符
        else:
            # 如果ope非空且c优先级小于栈顶，则ope循环出栈并将出栈元素压入res
            while ope and dic_out[c] < dic_in[ope[-1]]:
                res.append(ope.pop())
            # 如果ope非空且c优先级等于栈顶优先级，则出栈相消
            if ope and dic_out[c] == dic_in[ope[-1]]:
                ope.pop()
            # 如果ope空或c优先级高于栈顶元素，则直接压入ope
            else:
                ope.append(c)
    # 遍历结束后，将ope中剩下的元素全部出栈压入res
    while ope:
        res.append(ope.pop())
    # 返回res中的表达式
    return ''.join(res)
    
mid_pos(mid)
'ABCD-*+EF/-'
```

##### 中缀转前缀

思路：

与中缀转后缀类似，只需做三个切换即可：
- 反向遍历
- 反向输出
- 栈内站外优先级互换

分析：

有一点是不变的：优先级高的运算符先执行、先出栈。
- 优先级高的先出栈，先执行，而前缀表达式后面的运算符先执行，决定了结果栈输出方向与转后缀时相反
- 输出方向相反，而要保证左操作数在右操作数前面，遍历顺序也要相反
- 遍历顺序相反，要保证相同运算符栈外的优先级高，就要互换栈内站外运算符的优先级

算法：
```
mid = 'A+B*(C-D)-E/F'
def mid_pos(str):
    # 1. 栈内栈外优先级互换
    dic_out = {'(':1,'*':5,'/':5,'+':3,'-':3,')':6}
    dic_in = {'(':6,'*':4,'/':4,'+':2,'-':2,')':1}
    ope = []
    res = []
    # 2.反向遍历
    for c in mid[::-1]:
        if c.isalpha():
            res.append(c)
        else:
            while ope and dic_out[c] < dic_in[ope[-1]]:
                res.append(ope.pop())
            if ope and dic_out[c] == dic_in[ope[-1]]:
                ope.pop()
            else:
                ope.append(c)
    while ope:
        res.append(ope.pop())
    # 3. 反向输出
    return ''.join(res[::-1])
mid_pos(mid)
```
中缀转后缀思路更符合我们的思维习惯，只需记住中缀表达式转后缀表达式的思路即可。

#### 表达式计算算法
虽然中缀表达式是人们所习惯的表达方式，但是对于计算机来说它却很复杂，而后缀和前缀表达式则很容易求值。在计算中缀表达式的值时，通常需要先将中缀表达式转化为后缀或前缀表达式，然后再求值。

##### 计算后缀表达式
思路：

    1. 初始化一个栈，中间结果栈res
    2. 从左向右扫描表达式
    3. 遇到多位数字时，先计算数字真实值，num = num *10 + int(c),如果当前字符是数字且是最后一个字符或当前为运算符，则将刚刚保存的数值压入res
    4. 遇到操作符时，出栈两个元素运算后将结果压入栈
    5. 扫描结束，栈中的唯一元素就是表达式的结果

算法：

略，很容易实现，但后缀前缀表达式不好区分多位数，在后面计算中缀表达式时也会涉及这个过程。

##### 计算前缀表达式

思路：只需改变扫描方向，还有多位数字的处理

    1. 初始化一个栈，中间结果栈res
    2. 从右向左扫描表达式
    3. 遇到多位数字时，先计算数字真实值，num = num + int(c) * 10,如果当前字符是数字且是最后一个字符或当前为运算符，则将刚刚保存的数值压入res
    4. 遇到操作符时，出栈两个元素运算后将结果压入栈
    5. 扫描结束，栈中的唯一元素就是表达式的结
    
##### 计算中缀表达式（核心）

计算中缀表达式的算法是这部分的核心，既涉及到将中缀表达式转换为后缀表达式，又涉及到后缀表达式的计算。可以将该算法作为处理此类问题的模板。

思路：转换为后缀表达式的过程中计算后缀表达式

    1. 初始化两个栈：操作符栈ope、中间结果栈res
       初始化三个字典：栈内优先级dic_in、栈外优先级dic_out、操作符匿名函数对象dic_func
    2. 自左向右遍历中缀表达式
        2.1. 遇到多位数字时，先计算数字真实值，num = num * 10 int(c),
             如果当前数字且是最后一个字符或或下一个字符不是数字，则将刚刚保存的数值num压入res
        2.2. 遇到操作符c时，比较它与ope栈顶操作符的优先级：
            2.2.1.如果ope非空且c优先级小于栈顶优先级，则ope循环出栈,
            每次出栈时，res也依次出栈两个操作数x,y，计算c(y,x) 的值，并将结果压入栈res，
            直至ope栈为空或者c优先级高于等于栈顶优先级
            2.2.2 如果ope非空且c优先级等于栈顶优先级，说明遇到了')'，则将')'从ope出栈
            2.2.3 如果ope为空或c优先级高于等于栈顶优先级，则直接将c入栈ope
    3. 遍历结束时，将栈S1中的运算符循环出栈出栈后与4.1做同样处理
    4. res栈中唯一的元素既是最终表达式的解

通用模型

以下是使用栈处理实际问题的通用模型，当使用栈时脑中应唤起该模型：

- mid作为数据源，ope作为中转栈，res作为结果栈
- 确定数据入栈的条件和格式
- 确定数据出栈的条件
- 确定数据输出格式

![通用模型](http://note.youdao.com/yws/api/personal/file/WEB9448f68ff04994836c7c11a7d57b4397?method=download&shareKey=bdd0626a1a9efc0a7d1a1f6fd5de977e)



算法：
```
mid = '230+34*(32-35)-63/24'
def mid_pos(str):
    # 1.初始化优先级字典，操作符运算函数字典，操作符栈，中间结果栈
    dic_in = {'(':1,'*':5,'/':5,'+':3,'-':3,')':6}
    dic_out = {'(':6,'*':4,'/':4,'+':2,'-':2,')':1}
    dic_fun = {'+':lambda x,y:x+y,'-':lambda x,y:x-y,'*':lambda x,y:x*y,'/':lambda x,y:x/y,}
    ope = []
    res = []
    
    # 2. 扫描中缀表达式
    n = len(str)
    num = 0
    for i,c in enumerate(mid):
        # 遇到数字则求出多位数字的数值并压入res
        if c.isdigit():
            num = num * 10 +int(c)
            if i == n - 1 or not mid[i+1].isdigit():
                res.append(num)
                num = 0
        else:
            # 如果当前ope非空且字符优先级小于栈顶优先级，则ope循环出栈运算符，每次res出栈两个操作数，将计算结果压入res
            while ope and dic_out[c] < dic_in[ope[-1]]:
                y = res.pop()
                res[-1] = dic_fun[ope.pop()](res[-1],y)
            # 如果ope非空且字符优先级等于栈顶优先级，ope出栈相消
            if ope and dic_out[c] == dic_in[ope[-1]]:
                ope.pop()
            # 如果ope空或字符优先级大于栈顶优先级，则入栈
            else:
                ope.append(c)
    # 3. 扫描结束后，将ope剩余操作符出栈，方法与4.1相同
    while ope:
        y = res.pop()
        res[-1] = dic_fun[ope.pop()](res[-1],y)
    return res[-1]

mid_pos(mid),eval(mid)
(125.375, 125.375)
```

##### eval(string)函数
eval(string)函数会将字符串中的内容当做表达式来执行，并返回表达式的值。作为一般计算表达式的方法，没有必要通过后缀表达式来计算。或者在4.1步也可以使用eval(y + c + x)，但这样就失去后缀表达式计算的意义了。


