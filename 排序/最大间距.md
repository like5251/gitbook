### 问题
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Try to solve it in linear time/space.

Return 0 if the array contains less than 2 elements.

You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.

给定无序数组，找出排序后相邻元素的最大差，要求时间和空间复杂度均为O(n).比如给定：[5,9,8,3,15]
排序后为：[3,5,8,9,15]，相邻元素之差最大的是15-9=6，返回6

### 思路
本题难点是时间复杂度的要求O(n)，不能使用比较排序，思考分配排序，这里我们使用桶排序。

1. 划分
2. 分配
3. 排序
4. 收集

```python
def maximumGap(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    def bucket_sort(A):
        # 因为桶中元素区间为左闭右开区间，故最大值要加1
        ma,mi = max(A)+1,min(A)
        # 桶个数需与元素格式成比例，这里直接取为n
        m = n = len(A)

        # 分配函数：用于计算关键字所在桶号，取值范围0~m-1
        index = lambda x:(x-mi)*m/(ma-mi) 
        # 排序函数
        def insert_sort(A):
            for i in xrange(1,len(A)):
                cur,j = A[i],i-1
                while j>=0 and A[j]>cur:
                    A[j+1] = A[j]
                    j -= 1
                A[j+1] = cur

        # 1. 分配
        B = [[] for _ in xrange(m)]
        for num in A: B[index(num)].append(num)

        # 2. 排序
        for x in B: insert_sort(x)

        # 3. 收集
        A[:] = A[0:0]
        for x in B: A.extend(x)
    
    if not nums:return 0
    bucket_sort(nums)
    res = 0
    for i in xrange(1,len(nums)):
        res = max(res,nums[i] - nums[i-1])
    return res
```