## 归并排序(merge sort)
- 思路：二路归并排序基于分治和递归的思想，首先将序列分解为左右两个子序列，分别对左右子序列进行归并排序，再归并左右两个已排序序列

![](http://wuchong.me/img/Merge-sort-example-300px.gif)
- 实现

```python
def merge_sort(A,low,high):
    if low < high:
        mid = (low+high)/2          # 分解
        merge_sort(A,low,mid)       # 解决
        merge_sort(A,mid+1,high)
        merge(A,low,mid,high)       # 合并
        
def merge(A,low,mid,high):
    i,j,k=low,mid+1,low
    B = A[:]                        # 使用辅助数组B对A进行备份
    while i<=mid and j<=high:
        if B[i] < B[j]:             # 比较左右序列，将小的放入B
            A[k] = B[i]
            i += 1
        else:
            A[k] = B[j]
            j += 1
        k += 1
    if i <= mid:A[k:high+1]=B[i:mid+1]  # 前半段还有剩余，则直接添加到k后面
    if j <= high:A[k:high+1]=B[j:high+1]
```
- 分析
    - 时间复杂度：一趟归并需要O(n)，总共需要lgn趟归并，所以算法时间复杂度为O(nlgn)
    - 空间复杂度：merge操作中，辅助空间刚好占用n个单元，O(n)
    - 稳定性：merge操作不会改变相同关键字的顺序，稳定
