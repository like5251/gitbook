### 问题
Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....

Example:
(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. 
(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].

Note:
You may assume all input has valid answer.

Follow Up:
Can you do it in O(n) time and/or in-place with O(1) extra space?

给定一个未排序数组，重新排列使得数组满足nums[0] < nums[1] > nums[2] < nums[3]....，即偶数位置元素小于前后奇数位置的元素。

### 思路
#### 思路一
**思路**

1. 先对nums进行排序
2. 将前面小的那部分按逆序放置在偶数位置，将剩下部分按逆序放置在奇数位置

**实现**

```python 
def wiggleSort(self, nums):
    """
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """
    nums.sort()
    half = len(nums[::2])
    nums[::2],nums[1::2] = nums[:half][::-1],nums[half:][::-1]
```

**分析**
- 时间复杂度:O(nlgn)
- 空间复杂度:O(n)

#### 思路二
事实上，无需对nums进行排序，只需找到nums的中位数，然后将小于中位数的元素从后向前依次放至偶数位值，将大于中位数的元素从前向后依次放入奇数位置，将等于中位数的放入剩余位置。

**思路**

1. 通过快速选择算法找到nums的中位数mid，平均时间复杂度O(n)，空间复杂度O(1)
2. 这里使用了一种“虚拟索引”的技巧：将每个位置索引映射到一个新的索引`index(i) = (2*i+1)%(n|1) `，当我们仍然通过遍历i来依次访问nums[index(i)]时，事实上起到了改变nums的访问顺序的效果，我们只需要将nums[index(i)]中小于mid的交换到后面，大于mid的交换到前面即可：

```
# 原始索引
nums            [1, 1, 2, 2, 3, 3]
i                0  1  2  3  4  5 

# 虚拟索引
nums[index(i)]  [1, 2, 3, 1, 2, 3]
index(i)         1  3  5  0  2  4
i                0  1  2  3  4  5

# 按虚拟索引划分，所有小于mid的放后面，所有大于mid的放前面
nums[index(i)]  [3  3  2  2  1  1]
index(i)         1  3  5  0  2  4
i                0  1  2  3  4  5
nums[i]          2  3  1  3  1  2

```
**实现**

```python
def wiggleSort(self, nums):
    """
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """
    from random import randint
    def quik_select(A,l,r,i):
        # 选取第i小元素
        while l <= r:
            p = partition(A,l,r)
            k = p - l + 1
            if k == i:
                return A[p]
            elif k < i:
                l = p + 1
                i = i - k
            else:
                r = p - 1

    def partition(A,l,r):
        # 随机选取一个枢轴点，返回它在重排后的位置
        pivot = randint(l,r)
        A[l],A[pivot] = A[pivot],A[l]
        i = j = l+1

        while j <= r:
            if A[j] < A[l]:
                A[i],A[j] = A[j],A[i]
                i += 1
            j+= 1
        A[l],A[i-1] = A[i-1],A[l]
        return i-1
    
    # 重排
    n = len(nums)
    if n < 2:return
    index = lambda i:(2*i+1)%(n|1)      
    mid = quik_select(nums,0,n-1,(n+1)/2)
    
    i,low,high = 0,0,n-1
    while i <= high:
        if nums[index(i)] > mid:
            nums[index(i)],nums[index(low)] = nums[index(low)],nums[index(i)]
            low += 1
            i += 1
        elif nums[index(i)] < mid:
            nums[index(i)],nums[index(high)] = nums[index(high)],nums[index(i)]
            high -= 1
        else:
            i += 1
```

**分析**

- 时间复杂度O(n)
- 空间复杂度O(1)
























