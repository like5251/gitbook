## 插入排序(Insertion Sort)
基本思想：每次将一个待排元素插入到前面已排序列中，直至全部插入。

### 直接插入排序
- 思路：从1到n依次将待排元素插入到前面已排序列中，每次插入时，从后向前遍历已排序列，如果大于待排元素则后移一位，如果不大于待排元素或达到首部则插入待排元素。（注意比较到最后一个元素时需要特殊处理）

![](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)

- 实现：
```python
def insert_sort(A):
    for i in xrange(1,len(A)):
        cur,j = A[i],i-1
        while j>=0 and A[j]>cur:
            A[j+1] = A[j]
            j -= 1
        A[j+1] = cur
```
- 分析：
    - 时间复杂度：
        - 最好情况，元素已有序，仅需比较n次，无需移动，O(n);
        - 最坏情况，元素反序，O(n ^ 2)
    - 空间复杂度：O(1)
    - 稳定性：每次只会交换相邻元素，稳定
    - 适用：顺序表和链表

### 折半插入排序

- 思路：折半插入是直接插入的一个变种，在每次插入新的待排元素时，先使用二分查找在前面有序序列中找到插入位置，再统一移动插入位置到旧位置间的元素，最后插入待排元素

- 实现：
```python
def binsert_sort(A):
    for i in xrange(1,len(A)):
        l,r = 0,i-1
        while l <= r:
            mid = (l+r)/2
            if A[i] < A[mid]: r = mid - 1
            else:             l = mid + 1
            
        A[r+2:i+1],A[r+1] = A[r+1:i],A[i]
```
- 分析：
    - 时间复杂度：只减少了比较次数O(lgn)但并没有改变移动次数，仍为O(n^2)
    - 空间复杂度：O(1)
    - 稳定性：不改变相等元素的原始相对位置，稳定
    - 适用：顺序表

### 希尔(插入)排序(shell sort)
直接插入排序在规模较小或序列基本有序时效率较高，希尔排序正是先将序列减小规模，基本有序来提高直接插入排序的效率。
- 思想：按步长从n/2到1，反复进行直接插入排序。

![](https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif)
- 实现：
```python
def shell_sort(A):
    n = len(A)
    d = n/2
    while d:
        for i in xrange(d,n):
            cur,j = A[i],i-d
            while j>=0 and A[j]>cur:
                A[j+d] = A[j]
                j -= d
            A[j+d] = cur
        d = d/2
```
- 分析：
    - 时间复杂度：平均O(n^1.3)，最坏O(n ^ 2)
    - 空间复杂度：O(1)
    - 稳定性：当两个相同的元素被分到不同子组时顺序可能改变，不稳定
    - 适用：顺序表

