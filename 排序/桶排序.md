## 桶排序(bucket sort)
桶排序适用于输入数据比较均匀的情况。桶排序将整个元素区间划分为多个小区间（桶），将每个元素按照分配函数分配到每个桶中，对桶内元素进行排序之后，再将每个桶中的元素统一收集起来，就得到有序序列。桶排序时空复杂度均为O(n)。

- 思路：**划分-分配-排序-收集**（使用二维数组来表示基数队列）
    - 划分：将元素区间均匀划分为m个桶，初始化二维数组来表示桶、分配函数由元素值得到所对应的桶号、排序函数
    - 分配：将A中的元素按照非配函数分配到对应的桶中
    - 排序：对桶内元素进行排序
    - 收集：将B中桶中的元素依次收集到A中 

- 实现：

```python
def bucket_sort(A):
    # 1. 桶划分 
    # 因为桶中元素区间为左闭右开区间，故最大值要加1
    ma,mi = max(A)+1,min(A)
    # 桶个数需与元素格式成比例，这里直接取为n
    m = n = len(A)
    B = [[] for _ in xrange(m)]

    # 分配函数：用于计算关键字所在桶号，取值范围0~m-1
    index = lambda x:(x-mi)*m/(ma-mi) 
    # 排序函数
    def insert_sort(A):
        for i in xrange(1,len(A)):
            cur,j = A[i],i-1
            while j>=0 and A[j]>cur:
                A[j+1] = A[j]
                j -= 1
            A[j+1] = cur
    
    # 2. 分配
    for num in A: B[index(num)].append(num)
        
    # 3. 排序
    for x in B: insert_sort(x)
    
    # 4. 收集
    A[:] = A[0:0]
    for x in B: A.extend(x)
```
- 分析：
    - 时间复杂度：桶划分需要O(n)，桶收集需要O(n)，桶内排序和**桶个数**、数据是否**均匀**、所使用的**排序算法**有关。一般采用直接插入排序，在最好情况下，数据均匀分布，所有桶需要O(n2/m)，所以桶个数越多时间复杂度就越小，但是空间复杂度也就越大，一般取m=n，总时间复杂度为O(n)。最坏情况下，数据极不均匀，时间复杂度退化到所使用的桶内排序方法同样的时间复杂度。
    - 空间复杂度：需要m个桶，O(m),桶个数一般与n成正比,O(n)
    - 稳定性：桶排序是稳定的
