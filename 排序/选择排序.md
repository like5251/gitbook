## 选择排序
每次从当前待排序列中选择最小元素将其交换到首位，n-1轮完成排序。

### 简单选择排序(selection sort)
- 思路：每轮从A[i:]中选出最小元素与A[i]交换，i= 0...n-2

![](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)
- 实现：
```python
def SelectSort(A):
    n = len(A)
    for i in xrange(n-1):
        min = i
        for j in xrange(i+1,n):
            if A[j] < A[i]:min = j
        A[i],A[min] = A[min],A[i]
```
- 分析
    - 时间复杂度：元素移动次数最好情况是0，最坏情况是O(n)，元素比较次数和序列初始状态无关为n(n-1)/2;所以时间复杂度最好最坏都是O(n^2)
    - 空间复杂度：O(1)
    - 稳定性：存在跨距交换，不稳定

### 堆排序(heap sort)
#### 堆的基本概念
- 堆的定义：序列A[1,2...n]被称为堆，当且仅当该序列满足
    - ① `A[i] <= A[2i]` 且 `A[i] <= A[2i+1]，i∈[1,n//2]`,小根堆
    - ② `A[i] >= A[2i]` 且 `A[i] >= A[2i+1]，i∈[1,n//2]`,大根堆

- 堆与完全二叉树：将序列A看做是一颗完全二叉树，树的根节点是A[1]，给定一个节点的下标i，A[i/2]是它的父亲节点，A[2i]是它的左孩子，A[2i+1]是它的右孩子

#### 堆的基本算法
- **向下调整节点**：假设节点i的左右子树已是大根堆，向下调整i节点以使以i为根的子树也成为大根堆
    -  找到左右孩子中最大的，与父亲比较
    -  如果大于父亲，则父亲与孩子中较大的交换，然后递归向下调整较大子节点
    -  如果不大于父亲，则说明以i为根的子树已经是大根堆了

```python
# 堆以下标1开始，0分量可用于存储当前堆长度heap-size
def heapify(A,i,n):
    # i:将元素i向下调整
    # n:当前堆中元素个数
    l,r = 2*i,2*i+1
    if l <= n:
        largest = r if l<n and A[r] > A[l] else l
    else:
        largest = i
    if A[i] != A[largest]:
        A[i],A[largest] = A[largest],A[i]
        heapify(A,largest,n)

# 时间复杂度：O(h),h为堆的高度
```

- **建堆**：从n/2到1，依次向下调整节点

```python
def Build_max_heap(A):
    A[0] = len(A)-1                 # 使用A[0]存储当前堆容量
    for i in xrange(A[0]//2,0,-1):
        heapify(A,i,A[0])
# 时间复杂度：O(n)
```
#### 堆排序
- 堆排序：每轮交换堆顶和堆底元素，将堆长度减1，堆顶向下调整，n-1轮后堆中只剩一个元素，排序完成。

![](http://wuchong.me/img/Heapsort-example.gif)

```python
def heapsort(A):
    build_max_heap(A)               # 构建堆
    for i in xrange(len(A)-1,0,-1): # 堆排序：交换堆顶和堆底，堆长度-1，向下调整堆顶
        A[1],A[i] = A[i],A[1]
        heapify(A,1,i-1)
```

- 分析：
    - 时间复杂度：建堆过程花费O(n)，每次向下调整花费O(lgn)，排序过程需要交换、调整n-1次，所以堆排序时间复杂度为O(nlgn)
    - 空间复杂度：O(1)
    - 稳定性：不稳定

