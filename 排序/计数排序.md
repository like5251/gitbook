## 计数排序(Counting sort)
计数排序适用于序列元素在一个小区间内的情况。统计小于等于A[i]的元素个数并存放于C[A[i]-mi]，将A[i]分配至B[C[A[i]-mi]-1]中。时空复杂度为O(n)。

- 思路：**统计，分配**
    - 统计：统计小于等于A[i]的元素个数并存放于C[A[i]-mi]
    - 分配：A[i]分配至B[C[A[i]-mi]-1]中

- 实现：

```python
def count_sort(A):
    n = len(A)
    mi,ma = min(A),max(A)
    # C[i]存储A中A[i]-mi小于等于i的元素个数,B存储输出
    C = [0] * (ma-mi+1)
    B = [0] * n
    
    # 统计小于等于A[i]的元素个数，存储在C[A[i]-mi]
    for num in A:
        C[num-mi] += 1
    for i in xrange(1,ma-mi+1):
        C[i] = C[i] + C[i-1]
    
    # 小于等于A[j]的有C[A[j]]个，则A[j]存储在B[C[A[j]-mi]-1]处
    for j in xrange(n):
        B[C[A[j]-mi]-1] = A[j]
        # 重复元素处理
        C[A[j]-mi] -= 1
    
    A[:] = B
        
        
```
- 分析：
    - 时间复杂度：统计O(n+ma-mi+1)，收集O(n)，实际工作中当区间长度=O(n)时，才会用计数排序，故时间复杂度为O(n)
    - 空间复杂度：O(n)
    - 稳定性：计数排序是稳定的
