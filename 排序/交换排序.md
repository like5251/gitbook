## 交换排序
思想：根据序列中两个元素的比较结果来交换它们的位置。

### 冒泡排序(bubble sort)
- 思想：从前向后两两比较相邻元素，若逆序则交换；每轮冒泡都将当前最大元素排到最终位置（该元素不再参与下一轮排序），某轮冒泡不再发生交换或n轮冒泡后则排序成功。
- 实现：
```python
def bubble_sort(A):
    n = len(A)
    for i in xrange(n-1,0,-1):
        flag = False
        for j in xrange(i):
            if A[j] > A[j+1]:
                A[j],A[j+1] = A[j+1],A[j]
                flag = True
        if not flag:return
```
- 分析
    - 时间复杂度：
        - 最好情况下，初始有序，只比较n-1次，交换0次，O(n)；
        - 最坏情况下，初始逆序，O(n^2)；
    - 空间复杂度：O(1)
    - 稳定性：相等两元素不进行交换，稳定

### 快速排序（quick sort）
- 思想：基于分治和递归的思想，任选一个元素作为枢轴点，将所有小于它的元素都放在它前面，所有大于它的元素都放在后面，将枢轴点放在其最终位置，然后再递归排序枢轴点左右两侧子序列。

![](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)
- 实现：
    - ① 分解：
        - 选取A[0]作为枢轴值，将小于(等于)它的元素放在1~k，然后交换A[0]与A[k]，k是枢轴值最终位置
        - 过程使用“双指针滚动法”，j指针指向当前遍历位置(1~n-1)，i指针指向已存储的小于等于枢轴值的最后一个元素位置(1 ~ k)，如果A[j] <= A[0]就把A[j]与A[i+1]交换
    - ② 求解：递归求解0 ~ k-1，和k+1 ~ n-1子问题
    - ③ 合并：因为子序列都是原地排序，所以不用合并

```python
# 原地(in-place)快速排序
def partition(A,low,high):
    i = low
    for j in xrange(low+1,high+1):
        if A[j] <= A[low]:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i],A[low] = A[low],A[i]
    return i

def quiksort(A,low,high):
    if low < high:
        pivot = partition(A,low,high)   # 分解
        quiksort(A,low,pivot-1)         # 递归解决
        quiksort(A,pivot+1,high)

# 非原地快速排序,空间开销O(n)
def quiksort(A):
    if len(A) < 2:return True
    l = [x for x in a[1:] if x <= a[0]]
    r = [x for x in a[1:] if x > a[0]]
    return quiksort(l) + [a[0]] + quiksort(r)
```
- 分析：使用递归树来分析
    - 时间复杂度：递归深度×O(n)。递归深度和每次划分是否对称有关，最坏情况下初始有序或逆序，递归深度为n，时间复杂度为O(n^2)；最好情况下每次都进行均分，递归深度为lgn，时间复杂度为O(nlgn)；平均情况下，快排接近于最佳情况，为O(nlgn)。快速排序是内部排序中平均性能最好的排序算法。
    - 空间复杂度：递归深度×O(1),最坏O(n),最好O(lgn),平均O(lgn)
    - 稳定性：存在跨距交换，不稳定

- 改进：
    - 规模较小时不再继续递归调用，采取直接插入排序
    - 合理选取枢轴点：每次随机选取枢轴点或取头、尾、中间的中间值(将其与首元素交换，这样就不用修改以上代码)，这样最坏情况在实际中就几乎不会发生了。

