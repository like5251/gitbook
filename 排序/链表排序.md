### 插入排序
**问题** 
147. Insertion Sort List

**思路**
1. 使用头节点来简化操作
2. p.next指向有序链表中第一个节点，cur.next指向无序链表第一个节点，每次插入从前向后寻找插入位置
3. 注意比较至最后一个元素时，情况有所不同

**实现**

```python
def insertionSortList(self, head):
    """
    :type head: ListNode
    :rtype: ListNode
    """
    p = dummy = ListNode(0)
    cur = dummy.next = head
    # 初始时，p.next指向有序链表中第一个节点，cur.next指向无序链表第一个节点
    while cur and cur.next:
        while p.next.val < cur.next.val:
            p = p.next
        if p == cur:
            cur = cur.next
        else:
            tmp = cur.next.next
            cur.next.next = p.next
            p.next = cur.next
            cur.next = tmp
        p = dummy
    
    return dummy.next
```

### 归并排序
**问题**
Sort a linked list in O(n log n) time using constant space complexity.

**思路**
归并排序：
1. 分解：通过快慢指针找到链表中点，将链表分解为前后两个独立的链表
2. 求解：对两个链表进行递归排序
3. 合并：合并两个链表，返回头指针

**实现**
```python
def sortList(self, head):
    """
    :type head: ListNode
    :rtype: ListNode
    """
    # 处理递归边界
    if not head:return None
    if not head.next:return head
    
    # 寻找中点
    slow = fast = head
    while fast.next and fast.next.next:                           
        slow,fast = slow.next,fast.next.next
    # 链表拆分
    p = slow.next
    slow.next = None
    
    # 递归排序
    link1 = self.sortList(head)                                  
    link2 = self.sortList(p)
    
    # 创建头指针，方便合并
    newhead = cur = ListNode(None)
    while link1 and link2:
        if link1.val > link2.val:
            cur.next = link2
            cur = cur.next
            link2 = link2.next
        else:
            cur.next = link1
            cur = cur.next
            link1 = link1.next
    # 如果某个链表未合并完，只需将剩下部分加入到新链表
    if link1:cur.next = link1
    if link2:cur.next = link2
    
    # 返回头指针的下一个节点
    return newhead.next
```
**分析**
- 时间复杂度：O(nlgn)
- 空间复杂度：O(1)

### 多链表合并
****
