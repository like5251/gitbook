### 问题
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5

### 思路
问题的难点在于对时间复杂度要求O(lg(m+n))，应联想到折半查找。

1. 将问题转化为查找长度为(m+n)阶段有序数组上下中位数的平均值问题。无论奇偶上下中位数均可分别表示为第(m+n+1)/2小和第(m+n+2)/2小元素。
2. 使用二分查找求第k小元素的过程：比较k与m/2+n/2+1，其中假设nums[m//2] >= nums[n//2]
    1. 如果k <= mid，则`nums1[>=m//2]`部分至少为第k+1小,可将这部分排除，继续在`nums1[:m//2]`和nums2中找第k小
    2. 如果k > mid，则`nums2[<=n//2]`部分最多是第k-1小，可将这部分排除，继续在nums1和`nums2[n//2+1:]`中找第`k-n//2-1`小
    
### 实现
```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        # 无论奇偶下中位数都是第(n+1)/2小，上中位数都是(n+2)/2小
        return (self.get_kmin(nums1,nums2,(len(nums1)+len(nums2)+1)/2) + 
                self.get_kmin(nums1,nums2,(len(nums1)+len(nums2)+2)/2))/2.
        
    def get_kmin(self,nums1,nums2,k):
        m,n = len(nums1),len(nums2)
        if m==0 or n==0:                                # 边界判断:如果有一个为空则返回
            return nums1[k-1] if m else nums2[k-1]

        if nums1[m>>1] < nums2[n>>1]:                   # 确保nums1,m表示的是上中位数较大的那个数组
            nums1,m,nums2,n = nums2,n,nums1,m

        mid = (m>>1) + (n>>1) + 1
        if k <= mid:    # 如果k<=test，则nums1[>=m//2]部分至少为第k+1小，可移除这部分而不影响结果
            return self.get_kmin(nums1[:m//2],nums2,k)
        else:           # 如果k>test，nums2[<=n//2]部分最多是k-1小，因此可移除这部分而不影响结果
            return self.get_kmin(nums1,nums2[n//2+1:],k-n//2-1)

```
