### 问题
169.Majority Element

Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.

You may assume that the array is non-empty and the majority element always exist in the array.

查找无序数组中个数超过n//2的元素

### 思路

- 思路一：先排序，上下中位数即是。使用比较排序的话，时间至少需要O(nlgn)，空间O(1)
- 思路二：直接查找中位数（第n+1/2小元素），时间O(n)，空间O(lgn)
- 思路三：使用字典统计计数，计数大于n//2的元素即是所求。时间O(n),空间O(n)
- 思路四：多数投票法，每次统计一个人的票数，若多于一个人的则所有人票数减1，去掉票数为0的人，最后的到的候选人即是所求，时间O(n),O(1)

```python
# 思路一，先排序再找中位数
def majorityElement1(self, nums):
    nums.sort()
    return nums[len(nums)//2]
# 思路二，直接查找中位数
def majorityElement(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    from random import randint
    def quik_select(A,l,r,i):
        while l <= r:
        # 对A进行一次划分，返回枢轴点在划分后的位置p，前面的都小于A[p]，后面的都大于A[p]，A[p]为当前序列第p-l+1小元素
            p = partition(A,l,r)
            k = p - l + 1
            if k == i:
                return A[p]
            elif k < i:
                l = p + 1
                i = i - k
            else:
                r = p - 1

    def partition(A,l,r):
        # 随机选取一个枢轴点，返回它在划分后的位置
        pivot = randint(l,r)
        # 将选取的枢轴点交换到首位
        A[l],A[pivot] = A[pivot],A[l]
        # 指针i指示用于存储小于枢轴点的下个元素
        # 指针j指示当前检测元素
        i = j = l+1

        while j <= r:
            if A[j] < A[l]:
                A[i],A[j] = A[j],A[i]
                i += 1
            j+= 1
        # i-1处是最后一个小于枢轴点的元素，与枢轴点交换
        A[l],A[i-1] = A[i-1],A[l]
        return i-1
    
    return quik_select(nums,0,len(nums)-1,(len(nums)+1)/2)

# 思路三：使用字典统计计数
def majorityElement(self, nums):
    d = {}
    n = len(nums)
    for i,j in enumerate(nums):
        if j in d:
            d[j] += 1
        else:
            d[j] = 1
        if d[j] > n//2:
            return j

# 思路四：多数投票法，最高效、最简洁，三行核心代码
def majorityElement(self, nums):
    from collections import Counter
    c = Counter()
    for num in nums:
        c[num] += 1
        if len(c) == 2: c -= Counter(set(c))
    return c.keys()[0]

# 或者不使用字典
def majorityElement(self, nums):
    res,count = 0,0
    for num in nums:
        if count == 0:
            res = num
            count += 1
        else:
            if num == res: count += 1
            else:          count -= 1
    return res
```

### 总结——BM多数投票算法
> Boyer-Moore Majority Vote algorithm BM多数投票算法

#### 问题
229.Majority Element II

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.

一般地，**BM多数投票算法**用于查找无序数组中出现次数**超过**n/k的所有元素（最多有k-1个这样的元素）。

#### 思路

1. 选出候选者：从前向后计票，只保留k-1个人的票数，如果出现了第k个人的票，则将当前k个人的得票数都减1，去掉票数为0的人，最后留下的k-1个人即是候选者；
2. 检验候选者：检查每一位候选者在数组中的计数是否真的超过了n/k；

#### 实现

```python
def BM(nums,k):
    # 查找nums中出现次数超过n/k的所有元素，通用写法
    from collections import Counter
    ctr = Counter()
    for num in nums:
        ctr[num] += 1
        if len(ctr) == k:ctr -= Counter(set(ctr))
    return [x for x in ctr if nums.count(x) > len(nums)/k]

```

#### 分析

- 时间复杂度：O(kn)，k为常数，故时间复杂度为O(n)
- 空间复杂度：O(k)，k为常数，故空间复杂度为O(1)





























