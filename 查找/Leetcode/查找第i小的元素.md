### 问题
在无序序列A中查找第i小/大元素，如找出最小/最大、中位数问题。

中位数：对A进行排序后，处于中间位置的元素。当n为奇数时，中位数只有一个A[n//2]，当n为偶数时，中位数有两个，下中位数A[n//2]，上中位数A[n//2+1]，以下只讨论下中位数。

### 解法
#### 解法一：排序法
最直接的方式是先对序列进行排序，然后A[i-1]既是第i小的元素，但是这种方法的时间复杂度为min(O(in),O((n-i)N))。

#### 解法二：递归划分法
借用快速排序中“递归划分”的思路，可以在平均复杂度为O(n)内找到第i小元素。

**思路**：
1. 对序列A[l..r]进行递归划分，返回枢轴点在划分后序列中的下标p。为保证平均性能可采取随机选取枢轴点的方法
2. 如果i == p-l+1，则当前枢轴点既是第i小元素，直接返回
3. 如果i > p-l+1，说明第i小在后半部分，在后半部分[p+1..r]中递归求解第i-k小元素
4. 如果i < p-l+1，说明第i小在前半部分，在前半部分[l..p-1]中递归求解第i小元素

**实现**
```python
def quik_select(A,l,r,i):
    # i的合法性检查
    if i > (r-l+1) or i<0:return
    if l == r:return A[l]
    # 对A进行一次划分，返回枢轴点在划分后的位置，前面的都小于A[p]，后面的都大于A[p]，A[p]为当前序列第p-l+1小元素
    p = partition(A,l,r)
    k = p - l + 1         
    
    if k == i:
        return A[p]
    elif k < i:
        return quik_select(A,p+1,r,i-k)
    else:
        return quik_select(A,l,p-1,i)
        
def partition(A,l,r):
    # 随机选取一个枢轴点，返回它在划分后的位置
    pivot = randint(l,r)
    # 将选取的枢轴点交换到首位
    A[l],A[pivot] = A[pivot],A[l]
    # 指针i指示用于存储小于枢轴点的下个元素
    # 指针j指示当前检测元素
    i = j = l+1
    
    while j <= r:
        if A[j] < A[l]:
            A[i],A[j] = A[j],A[i]
            i += 1
        j+= 1
    # i-1处是最后一个小于枢轴点的元素，与枢轴点交换
    A[l],A[i-1] = A[i-1],A[l]
    return i-1
```
**分析**
- 时间复杂度：平均情形下T(n) = T(n/2) + n，时间复杂度O(n)
- 空间复杂度：递归深度O(lgn)










