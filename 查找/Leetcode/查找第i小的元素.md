### 问题
输入：包含n个互异元素的集合A，一个整数`i(1<=i<=n)`
输出：元素x，A中恰有i-1个元素小于它

中位数：对A进行排序后，处于中间位置的元素。
- n为奇数时，只有一个中位数，i = (n+1)//2
- n为偶数时，有两个中位数，下中位数i = n/2，上中位数i = n/2+1
- n不分奇偶时，下中位数统一表示为i = (n+1)//2，上中位数统一表示为(n+2)//2;分别对应下标(n-1)//2和n//2

### 解法
如果是查找最小/最大元素，只需要遍历一次即可找到，时间复杂度O(n)。以下讨论查找一般的第i小元素的方法。

#### 解法一：排序法
最直接的方式是先对序列进行排序，然后A[i-1]既是第i小的元素，但是这种方法的平均时间复杂度为O(nlgn)。

#### 解法二：快排划分-折半查找
借用快速排序中“递归划分”的思路，可以在O(n)的线性时间内找到第i小元素。

**思路**：
1. 对序列A[l..r]进行递归划分，返回枢轴点在划分后序列中的下标p。为保证平均性能可采取随机选取枢轴点的方法
2. 如果i == p-l+1，则当前枢轴点既是第i小元素，直接返回
3. 如果i > p-l+1，说明第i小在后半部分，在后半部分[p+1..r]中递归求解第i-k小元素
4. 如果i < p-l+1，说明第i小在前半部分，在前半部分[l..p-1]中递归求解第i小元素

**实现**
```python
def quik_select(A,l,r,i):
    while l <= r:
    # 对A进行一次划分，返回枢轴点在划分后的位置p，前面的都小于A[p]，后面的都大于A[p]，A[p]为当前序列第p-l+1小元素
        p = partition(A,l,r)
        k = p - l + 1
        if k == i:
            return A[p]
        elif k < i:
            l = p + 1
            i = i - k
        else:
            r = p - 1
                    
def partition(A,l,r):
    # 随机选取一个枢轴点，返回它在划分后的位置
    pivot = randint(l,r)
    # 将选取的枢轴点交换到首位
    A[l],A[pivot] = A[pivot],A[l]
    # 指针i指示用于存储小于枢轴点的下个元素
    # 指针j指示当前检测元素
    i = j = l+1
    
    while j <= r:
        if A[j] < A[l]:
            A[i],A[j] = A[j],A[i]
            i += 1
        j+= 1
    # i-1处是最后一个小于枢轴点的元素，与枢轴点交换
    A[l],A[i-1] = A[i-1],A[l]
    return i-1
```
**分析**
- 时间复杂度：平均情形下T(n) = T(n/2) + n，时间复杂度O(n)
- 空间复杂度：递归深度O(lgn)










