# 二分查找
二分查找（binary search）又称折半查找（half-interval search），用于在有序表中快速查找元素，首先确定查找窗口，如果查找窗口非空，则在窗口内选择一个元素作为枢轴点与目标值进行比较，如果等于目标值则直接返回，如果小于目标值则继续在左半窗口进行二分查找，如果大于目标则继续在右半窗口进行二分查找，如果最终窗口为空仍未找到目标元素则返回目标元素应插入的位置下标。最坏时间复杂度为O(lgn)。

二分查找是考实际考察最多的查找算法！其通用框架如下：

**使用前提**：在查找范围内，关键字是位置的单调函数。

**通用算法**：

1. 初始化查找窗口：使用位置变量来表示当前查找窗口范围，可以使用闭区间表示$$[l,r]$$或开区间表示$$[l,r)$$
2. 如果查找窗口不为空则循环以下过程：
    1. 在查找窗口内选取一个元素作为枢轴点，与目标值进行比较
    2. 如果目标值等于枢轴值，则返回枢轴点下标
    3. 如果目标值大于数轴值，则在枢轴点右侧窗口继续查找
    4. 如果目标值小于枢轴值，则在枢轴点左侧窗口继续查找
3. 如果窗口为空仍未找到目标值，则返回目标值应插入位置的下标
     
### 闭区间折半查找
如果严格按照以上

**算法思路**：

1. 表示查找窗口：使用位置变量来表示当前查找窗口范围，可以使用闭区间表示$$[l,r]$$或开区间表示$$[l,r)$$；
2. 如果窗口不为空则循环以下过程：
    1. 确定枢轴点：一般取下中位数作为枢轴点（下中位数对应$$\frac{l+r}{2}$$位置，上中位数对应$$\frac{l+r+1}{2}$$位置）
    2. 如果目标值等于枢轴值，则返回数轴值下标
    3. 如果目标值大于数轴值，则在枢轴点右侧继续查找
    4. 如果目标值小于枢轴值，则在枢轴点左侧继续查找
3. 如果未找到目标值，则目标值一定处于l和r之间；

**注意边界**：无论是用闭区间还是开区间来表示窗口，折半查找全程必须满足“循环不变性”，即每次迭代完成都必须保证窗口表示的一致性，否则可能会出现死循环或边界错误。

**普通折半查找的两个关键点**：枢轴点的选取位置不是关键，只要在窗口范围内即可，窗口边界才是折半查找的关键!
1. 初始边界：闭区间l=0,r=n-1;开区间l=0,r=n
2. 退出边界：闭区间l=r+1;开区间l=r

```python
# 闭区间写法:用[l,r]代表当前查找范围
def Binary_search(L,key):
    '''
    @L:有序数组
    @key:目标值
    @return:如果查找成功则返回目标元素索引，如果查找失败则返回目标值应插入的位置
    '''
    # 闭区间-初始化窗口
    l,r = 0,len(L)-1 
    # 闭区间-退出条件：窗口内不含元素，l=r+1
    while l <= r:
        mid = (l + r)//2
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid - 1

    return l
```

```python
# 开区间写法:用[l,r)代表当前查找范围
def Binary_search(L,key):
    # 开区间-初始化窗口
    l,r = 0,len(L) 
    # 开区间-退出条件：窗口内不含元素，l=r
    while l < r: 
        # 防止l+r溢出的写法
        mid = l + (r-l)//2
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid 
    
    return l
```

### 含相同元素的折半查找
当列表中含有相同元素时，如果仅仅是需要找到其中任意一个与目标值相等的元素，则以上代码无需改变。但如果需要寻找第一个/最后一个等于目标值的元素，只需要在原来代码的基础上将等于当做小于/大于来处理，



```python
# 返回第一个满足条件的下标
def Binary_search(L,key):
    l,r = 0,len(L)-1
    last = -1
    while l <= r:
        mid = l + (r-l)/2
        if key == L[mid]:
            last = mid
            r = mid - 1
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid -1
    return last

# 返回最后一个满足条件的下标
def Binary_search(L,key):
    l,r = 0,len(L)-1
    last = -1
    while l <= r:
        mid = l + (r-l)/2
        if key == L[mid]:
        last = mid
        l = mid + 1
    elif key > L[mid]:
        l = mid + 1
    else:
        r = mid -1
    return last
```
- 分析：
    - 最坏时间复杂度：O(lgn)
    - ASL ≈ lg(n+1)-1

折半查找每次选取中间元素作为枢轴点，插值查找和斐波那契查找通过改变枢轴点的选取方式对折半查找进行了改进。插值查找每次以插值的方式确定枢轴点，适合于元素关键字分布比较均匀的情况，斐波那契查找则是每次选取黄金分割点作为枢轴点。

## 插值查找

插值查找每次通过插值的方式来选取枢轴点：

- 插值查找：`mid = l + (r-l)*(key-L[l])/(L[r]-L[l])`，其中`L[r] != L[l],L[l] <= key <= L[r]`
```python
def insertion_search(L,key):
    l,r = 0,len(L)-1
    while l <= r:
        if key > L[r] or key < L[l]:return -1
        if L[r] == L[l]:return r
        mid = int(l + (r-l)*(key-L[l])/float((L[r]-L[l])))
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid - 1
    return -1
```

- 分析：平均时间复杂度O(loglogN)，当关键字在数据集中分布较均匀时性能最好，当分布不均时可能比折半要差

## 斐波那契查找

1. 找到大于F[k]-1 >= n的第一个k，在列表后面补充最后一个元素，使列表长度恰好为F[k]-1
2. 选取mid = l+F[k-2]-1，恰好将列表分为左右F[k-2]-1和F[k-1]-1个元素
3. 接下来和折半查找过程一致，只需判断相等时mid是否大于n-1

```python
F = [0,1]
def Fibonacci(k):
    if k < len(F):
        return F[k]
    else:
        p = Fibonacci(k-1) + Fibonacci(k-2)
        F.append(p)
    return p

def Fibonacci_Search(L,key):
    n = len(L)
    k = 0
    while n > Fibonacci(k) - 1:
        k += 1
    
    L = L + L[-1:] * (F[k]-1-n)
    l,r = 0,n-1
    while l <= r:
        mid = l+ F[k-2] - 1
        if key == L[mid]:
            if mid >=n:
                return n-1
            else:
                return mid
        elif key > L[mid]:
            l = mid + 1
            k -= 1
        else:
            r = mid - 1
            k -= 2
    return -1
```
- 分析：同样，斐波那契查找的时间复杂度还是O(log2n)，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定
