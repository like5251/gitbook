# 二分查找
二分查找（binary search）又称折半查找（half-interval search），用于在有序列表中快速查找元素，最坏时间复杂度为O(lgn)。二分查找是考实际察最多的查找算法！

### 普通折半查找

**使用前提**：在查找范围内，关键字是位置的单调函数。

**算法思路**：
1. 表示查找范围：

将待查关键字key与中间位置关键字比较，若相等则查找成功，若大于则在后半部分折半查找，若小于则在前半部分折半查找，直至查找成功或越出边界。
- 一般模板：推荐闭区间写法，简单易用

```python
# 如果查找成功则返回目标元素索引，如果查找失败则返回最后一个比它小的元素索引
def Binary_search(L,key):
    l,r = 0,len(L)-1 # 闭区间写法
    while l <= r:
        mid = l + (r-l)/2 # 防溢出，但在python中不存在溢出
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
        r = mid - 1
    return r # 如果查找失败，则L[r]<key<L[l]，l = r+1
```

- 边界处理：折半查找全程必须满足“循环不变性”，否则可能会出现死循环或边界错误。循环不变性在这里指的就是“l-r区间表示方式必须前后一致”：
    - 闭区间：用[l,r]代表当前查找的范围
    - 前闭后开：用[l,r)代表当前查找范围

```python
# 如果查找成功则返回目标元素索引，如果查找失败则返回第一个比它大的元素索引
def Binary_search(L,key):
    l,r = 0,len(L) # 开区间
    while l < r: # 边界写法
        mid = l + (r-l)/2
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid # 前半部分
    return r # 如果查找失败,L[r]>key, l == r
```

- 变形：当列表中含有相等元素时，如果需要返回第一个或最后一个满足条件的下标，可使用last记录上一次满足条件的元素下标，把相等当做小于/大于，最后返回last。

```python
# 返回第一个满足条件的下标
def Binary_search(L,key):
    l,r = 0,len(L)-1
    last = -1
    while l <= r:
        mid = l + (r-l)/2
        if key == L[mid]:
            last = mid
            r = mid - 1
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid -1
    return last

# 返回最后一个满足条件的下标
def Binary_search(L,key):
    l,r = 0,len(L)-1
    last = -1
    while l <= r:
        mid = l + (r-l)/2
        if key == L[mid]:
        last = mid
        l = mid + 1
    elif key > L[mid]:
        l = mid + 1
    else:
        r = mid -1
    return last
```
- 分析：
    - 最坏时间复杂度：O(lgn)
    - ASL ≈ lg(n+1)-1

折半查找每次选取中间元素作为枢轴点，插值查找和斐波那契查找通过改变枢轴点的选取方式对折半查找进行了改进。插值查找每次以插值的方式确定枢轴点，适合于元素关键字分布比较均匀的情况，斐波那契查找则是每次选取黄金分割点作为枢轴点。

## 插值查找

插值查找每次通过插值的方式来选取枢轴点：

- 插值查找：`mid = l + (r-l)*(key-L[l])/(L[r]-L[l])`，其中`L[r] != L[l],L[l] <= key <= L[r]`
```python
def insertion_search(L,key):
    l,r = 0,len(L)-1
    while l <= r:
        if key > L[r] or key < L[l]:return -1
        if L[r] == L[l]:return r
        mid = int(l + (r-l)*(key-L[l])/float((L[r]-L[l])))
        if key == L[mid]:
            return mid
        elif key > L[mid]:
            l = mid + 1
        else:
            r = mid - 1
    return -1
```

- 分析：平均时间复杂度O(loglogN)，当关键字在数据集中分布较均匀时性能最好，当分布不均时可能比折半要差

## 斐波那契查找

1. 找到大于F[k]-1 >= n的第一个k，在列表后面补充最后一个元素，使列表长度恰好为F[k]-1
2. 选取mid = l+F[k-2]-1，恰好将列表分为左右F[k-2]-1和F[k-1]-1个元素
3. 接下来和折半查找过程一致，只需判断相等时mid是否大于n-1

```python
F = [0,1]
def Fibonacci(k):
    if k < len(F):
        return F[k]
    else:
        p = Fibonacci(k-1) + Fibonacci(k-2)
        F.append(p)
    return p

def Fibonacci_Search(L,key):
    n = len(L)
    k = 0
    while n > Fibonacci(k) - 1:
        k += 1
    
    L = L + L[-1:] * (F[k]-1-n)
    l,r = 0,n-1
    while l <= r:
        mid = l+ F[k-2] - 1
        if key == L[mid]:
            if mid >=n:
                return n-1
            else:
                return mid
        elif key > L[mid]:
            l = mid + 1
            k -= 1
        else:
            r = mid - 1
            k -= 2
    return -1
```
- 分析：同样，斐波那契查找的时间复杂度还是O(log2n)，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定
