> 散列表也叫哈希表（Hash table），是对普通数组概念的推广，对普通数组可以直接寻址，在O(1)时间内访问数组中任意位置的元素。但当实际存储的关键字个数远小于全部可能的关键字个数时，直接寻址会造成大量的空间浪费。散列表根据关键字计算出相应的下标而不是将关键字直接作为下标，既保持了O(1)的查找时间复杂度又降低了空间复杂度。

## 基本概念
- 哈希表：是根据关键字直接进行访问的数据结构。哈希表建立了关键字到存储地址之间的一种直接映射关系。
- 哈希函数：把关键字映射称地址的函数，Hash(key)=address,address可以是数组下标、索引或内存地址
- 冲突：把不同关键字映射到同一地址
- 同义词：通过哈希函数被映射到同一地址的多个关键字互为同义词
- 均匀散列：不同关键字被等可能地散列到m个槽中任何一个，且与其他元素被散列到什么位置无关
- 槽/单元：哈希表中的每个位置称为槽
- 装填因子：α = 表中记录数n/哈希表长度m，装填因子描述了哈希表发生冲突的可能性大小，α可能小于等于大于1。对于拉链法，装填因子即一个链的平均长度；对于开放寻址法，α<=1；
- 聚集：第一哈希地址不同的两个关键字争夺同一个后继哈希地址的现象，解决同义词冲突的过程又引入了非同义词冲突。

## 散列函数构造方法
一个好的散列函数应尽可能满足均匀散列。以下是常用的散列函数：
- 直接寻址法：选取关键字的某个线性函数值作为散列地址，特别地，当a=1 b = 0时，即是直接将关键字作为地址/下标。

$$
H(key) = a\times key+b
$$

- 除留余数法：这是最简单最常用的方法，假设哈希表长度为m，取一个不大于m且不太接近2的整数幂的素数p作为除数：

$$
H(key) = key \% p
$$

- 平方取中法：取关键字的平方值的中间几位作为散列地址

- 全域散列法：随机选择散列函数使之独立于要存储的关键字

## 冲突处理方法
任何散列函数都不可能绝对避免冲突，必须考虑发生冲突时应该如何进行处理。常用方法有开放寻址法和拉链法。

### 1. 开放寻址法
开放寻址法：空闲地址既向它的同义词开放也向它的非同义词开放。

![](/assets/27222340-9f285bd1c87d438e9a8ffb75db9ea37d.png)

#### 冲突探测过程
当发生冲突时，开放寻址法会进行**多次探查**，直至找到空闲地址或不再有空闲地址，第i次探查的散列地址的递推公式如下：
$$
H_{i} = (H(key)+d_{i})\%m
$$

- H(key)为哈希函数
- m 为哈希表长度
- Hi代表第i次探测的位置，i = 1,2,...,m-1
- di代表增量序列

根据增量序列选取方式的不同，又有以下探测方法：

1. 线性探测法：$$d_{i} = 1,2,...,m-1$$，当冲突发生时顺序探测表中下一个单元，直到找到一个空闲单元或查遍全表。线性探测法可能使第i个散列地址的同义词存入第i+1个散列地址，本应存储到第i+1个位置的元素就争夺第i+2个地址...从而造成大量元素在相邻地址“聚集”，降低查找效率。
- 平方探测法：$$d_{i} = 1^{2},-1^{2},2^{2},-2^{2},...,k^{2},-k^{2}$$,`k<=m/2`，`m = 4k+3`的质数。平方探测法能避免出现聚集但只能探测到一半单元
- 再散列法：$$d_{i} = H_{2}(key)$$
- 伪随机法：$$d_{i}$$=伪随机序列

#### 查找
使用开放寻址法进行散列表查找的一般过程如下：

1. 计算原始哈希地址：根据关键字通过哈希函数计算对应的哈希地址
2. 冲突检测：如果当前哈希地址为空则查找失败，如果非空则比较当前单元关键字与目标关键字，相等则查找成功，不相等则继续探查下一个哈希地址，直至找到对应关键字则查找成功或找到空地址查找失败

分析：
- 时间复杂度：只需通过常数次查找（<=m）,故时间复杂度为$$O(1)$$
- 平均查找长度：
    - 按照哈希表中已存储的元素分类：ASL(成功) = (每个已存储元素查找冲突次数+1再求和)/已存储元素个数
    - 按照哈希表中所有位置分类：ASL(失败) = (原始哈希地址为i位置，但查找失败的冲突次数+1再求和)/哈希表长度
- 查找成功时，期望探查次数不超过$$\frac{1}{\alpha }ln\frac{1}{1-\alpha }$$
- 查找不成功时，期望探查次数不超过$$\frac{1}{1-\alpha }$$

#### 插入
使用开放寻址法进行散列表插入的一般过程和查找过程类似：
1. 计算原始哈希地址：根据关键字通过哈希函数计算对应的哈希地址
2. 冲突检测：如果当前哈希地址为空则将关键字直接插入，如果非空则继续探查下一个哈希地址，直至找到空地址将关键字插入或探查完哈希表所有位置，说明哈希表已满

分析：
- 平均时间复杂度：$$O(1)$$
- 插入一个元素的期探查次数不超过$$\frac{1}{1-\alpha }$$

#### 删除
使用开放寻址法不能随便删除表中已有元素，因为会截断具有相同散列地址的元素的探测过程，更常见的做法是通过拉链法来解决冲突。

### 2. 拉链法
拉链法：将同义词存储在同一个链表中，并将链表的头指针存储在散列表对应的哈希地址单元中。

#### 拉链法性能分析
- 散列表的查找、插入和删除操作都是在同义词链表中进行，时间复杂度O(1)
- 查找成功/不成功的平均时间O(1+α)

![](/assets/27225206-e969b13cdc2c4fa4867888838ed26d15.png)

### 对比开放寻址法和拉链法
- 拉链法适用于经常需要插入和删除的情况
- 开放寻址法不用存储额外指针，节省了空间以提供更多的散列单元，潜在的减少了冲突，提高了查找效率