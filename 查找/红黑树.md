## 红黑树（RBT, red_black_tree）
红黑树本质上是一种**近似平衡的二叉查找树**，它在二叉查找树的基础上额外添加了一个标记（颜色），同时附带了一定的规则，这些规则保证了RBT总是近似平衡，在最坏情况下动态集合基本操作的时间复杂度为O(lgn)。

### 定义
- 逻辑结构：

一棵红黑树是满足以下红黑性质的二叉查找树：
1. 每个节点要么是红色，要么是黑色
2. 根节点是黑色的
3. 叶节点(None)都是是黑色的
4. 从根节点到叶节点的任一条路径，红色节点不能连续出现
5. 从根节点到叶节点的任一条路径，黑色节点数相等

![](http://images.cnitblog.com/blog/305504/201301/30173608-ccdbf138e6114c9ea8044bae6e4e6228.png)

- 存储结构：
```python
class TreeNode(object):
    def __init__(self, x):
        self.val = x         # 关键字
        self.left = None     # 左孩子
        self.right = None    # 右孩子
        self.p = None        # 父节点
        self.color = None    # 节点颜色
```


### 红黑树高度
一棵有n个内部节点的红黑树高度最大为2lg(n+1)，因此动态集合操作（查找、查找最大/最小、查找前驱/后继、插入、删除）可以在红黑树上在O(lgn)时间内执行。

证明：设从根节点到叶节点的一条路径中黑色节点数为bh，则红黑树中节点数$$nn\geq 2^{bh}-1$$（假设去掉所有红色节点的话）；又$$bh\geq h/2$$（由性质4），所以：

$$
n\geq 2^{h/2}-1
$$

$$
h\leqslant 2lg(n+1)
$$


### 旋转
插入和删除操作之后，需要通过旋转和染色继续保持树的红黑性质。旋转是一种能够保持二叉查找树性质的查找树局部操作，可分为左旋和右旋：

![](https://user-gold-cdn.xitu.io/2016/11/29/45e6629fc939b2140fa30b885a0db6bf?imageView2/0/w/1280/h/960)

旋转可概括为：支轴端点“换子上位臣服”的过程，以左旋为例，① 子树y将自己处于中间的孩子β过继给父节点x；② 然后自己上位至父节点位置；③ x作为y的左孩子。

```python
def left_rotate(T,x):
    y = x.right
    x.right = y.left            # 换子
    if y.left: y.left.p = x
    
    y.p = x.p                   # 上位
    if x.p == None:
        T = y
    elif x == x.p.left:
        x.p.left = y
    else:
        x.p.right = y
    
    y.left = x                  # 臣服
    x.p = y
```
- 时间复杂度：O(1)

### 插入

为了在新节点插入后仍保持红黑树性质，插入的一般过程是：

- 以二叉查找树的方式插入新节点并标记为红色
- 进行局部旋转和颜色调整

```python
def RB_insert(T,z):
        tree_insert(T,z)        # 插入节点
        z.color = red           # 初始化新节点颜色为红色 
        RB_insert_fixup(T,z)    # 局部旋转和颜色调整
```
循环调整过程的循环不变式：
    - z是红色
    - 至多有一条红黑树性质被破坏，如果z.p为黑色则红黑树未被破坏不用调整；如果z是根节点，性质2被破坏，如果z.p为红色则性质4被破坏。

调整过程分一下几种情形来讨论：

1. z.p为黑色，T已经是红黑树，不用调整
2. z.p为红色，需分情况来调整
    1. z.p是左支
        1. z的叔节点是红色，将z的父、叔改为黑色，祖父改为红色，无需旋转，z转至z.p.p
        2. z的叔节点为黑色，如果z是右支，先左旋，z转至z.p，转化为case3
        3. z的叔节点为黑色，如果z是左支，将z的父节点改为黑，祖父节点改为红，再右旋转，while结束
    2. z.p是右支，只需将right和left互换
3. 将根节点置为黑色

```python
def RB_insert_fixup(T,z):
    while z.p.color == red:
        if z.p == z.p.p.left:
            y = z.p.p.right
            if y.color == red:
                z.p.color = black
                y.color = black
                z.p.p.color = red
                z = z.p.p
            else:
                if z == z.p.right:        # LR旋转
                    z = z.p
                    left_rotate(T,z)
                z.p.color = black         # LL旋转
                z.p.p.color = red
                right_rotate(T,z.p.p)
        else:
            只需将以上left和right互换
    T.color = black
```

- 时间复杂度：O(lgn)

### 删除
红黑树的删除操作要更加复杂一些，详细过程参考算法导论p183，这里不再赘述，只需要知道删除操作的时间复杂度也是O(lgn)。


## 参考

[面试旧敌之红黑树（直白介绍深入理解）](https://juejin.im/entry/58371f13a22b9d006882902d#红黑树的平衡删除)






